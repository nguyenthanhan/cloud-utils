#!/bin/zsh

# =============================================================================
# Database Connection Tool - SSH Tunnel Manager (Enhanced Version)
# =============================================================================
# This script manages SSH tunnels to connect to remote database services.
# VPS configurations are loaded from secrets file (mac_scripts_secrets).
#
# Secrets file location:
#   ~/Library/Mobile Documents/com~apple~CloudDocs/Backups/mac_scripts_secrets
#
# VPS_CONFIGS format:
#   "VPS_NAME|USER|IP|SERVICE_NAME|SERVICE_ICON|LOCAL_PORT|REMOTE_HOST|REMOTE_PORT"
#
# To add/remove VPS: Edit VPS_CONFIGS array in the secrets file
# =============================================================================

# Global variables
typeset -g SSH_TIMEOUT=10

# Auto-load VPS configurations from secrets file
# This ensures we always use the latest configurations
{
    local icloud_drive_root="${HOME}/Library/Mobile Documents/com~apple~CloudDocs"
    local secrets_file="${icloud_drive_root}/Backups/mac_scripts_secrets"
    
    if [[ -f "$secrets_file" ]]; then
        # Source secrets file and suppress all output (including debug output)
        {
            source "$secrets_file" 2>/dev/null
        } >/dev/null 2>&1
        
        if [[ -z "${VPS_CONFIGS[@]}" ]]; then
            echo "‚ö†Ô∏è  Warning: VPS_CONFIGS not found in secrets file"
            echo "   Please define VPS_CONFIGS array in $secrets_file"
            typeset -a VPS_CONFIGS=()
        fi
    else
        echo "‚ö†Ô∏è  Warning: Secrets file not found at $secrets_file"
        echo "   Please create the file and define VPS_CONFIGS array"
        typeset -a VPS_CONFIGS=()
    fi
}

# =============================================================================
# Utility Functions
# =============================================================================

# Log message to stdout
log() {
    local level=$1
    shift
    local message="$@"
    
    if [[ "$level" == "ERROR" ]]; then
        echo "‚ùå $message" >&2
    elif [[ "$level" == "WARN" ]]; then
        echo "‚ö†Ô∏è  $message"
    elif [[ "$level" == "INFO" ]]; then
        echo "‚ÑπÔ∏è  $message"
    fi
}

# Parse config string into variables
# Returns 0 on success, 1 on failure
parse_config() {
    local config=$1
    local vps_name_var=$2
    local user_var=$3
    local ip_var=$4
    local service_name_var=$5
    local icon_var=$6
    local local_port_var=$7
    local remote_host_var=$8
    local remote_port_var=$9
    
    IFS='|' read -r vps_name user ip service_name icon local_port remote_host remote_port <<< "$config"
    
    # Validate config format (should have 8 fields)
    local field_count=$(echo "$config" | tr '|' '\n' | wc -l | tr -d ' ')
    if [[ $field_count -ne 8 ]]; then
        log "ERROR" "Invalid config format (expected 8 fields, got $field_count): $config"
        return 1
    fi
    
    # Validate port numbers
    if ! [[ "$local_port" =~ ^[0-9]+$ ]] || ! [[ "$remote_port" =~ ^[0-9]+$ ]]; then
        log "ERROR" "Invalid port number in config: $config"
        return 1
    fi
    
    # Validate port range
    if [[ $local_port -lt 1 ]] || [[ $local_port -gt 65535 ]] || \
       [[ $remote_port -lt 1 ]] || [[ $remote_port -gt 65535 ]]; then
        log "ERROR" "Port out of range (1-65535) in config: $config"
        return 1
    fi
    
    # Set variables using eval (safe here as we control the variable names)
    eval "${vps_name_var}='${vps_name}'"
    eval "${user_var}='${user}'"
    eval "${ip_var}='${ip}'"
    eval "${service_name_var}='${service_name}'"
    eval "${icon_var}='${icon}'"
    eval "${local_port_var}='${local_port}'"
    eval "${remote_host_var}='${remote_host}'"
    eval "${remote_port_var}='${remote_port}'"
    
    return 0
}

# Check if a port is in use
is_port_in_use() {
    local port=$1
    if lsof -iTCP:${port} -sTCP:LISTEN -t > /dev/null 2>&1; then
        return 0  # Port is in use
    else
        return 1  # Port is free
    fi
}

# Get process info for a port
get_port_process_info() {
    local port=$1
    local pid=$(lsof -iTCP:${port} -sTCP:LISTEN -t 2>/dev/null | head -n1)
    
    if [[ -n "$pid" ]]; then
        local cmd=$(ps -p "$pid" -o command= 2>/dev/null | head -n1)
        echo "PID: $pid, CMD: ${cmd:0:60}"
    else
        echo "No process found"
    fi
}

# Check if port is used by our SSH tunnel
is_our_ssh_tunnel() {
    local port=$1
    local pid=$(lsof -iTCP:${port} -sTCP:LISTEN -t 2>/dev/null | head -n1)
    
    if [[ -n "$pid" ]]; then
        local cmd=$(ps -p "$pid" -o command= 2>/dev/null)
        if echo "$cmd" | grep -q "ssh.*-L.*${port}"; then
            return 0  # It's our tunnel
        fi
    fi
    return 1  # Not our tunnel
}

# Test SSH connectivity to a host
test_ssh_connection() {
    local user=$1
    local ip=$2
    local vps_name=$3
    local vps_host="${user}@${ip}"
    
    log "INFO" "Testing SSH connection to ${vps_name} (${ip})..."
    
    # Use timeout if available, otherwise use SSH's ConnectTimeout
    if command -v timeout >/dev/null 2>&1; then
        if timeout ${SSH_TIMEOUT} ssh -o ConnectTimeout=${SSH_TIMEOUT} \
           -o BatchMode=yes -o StrictHostKeyChecking=no \
           "$vps_host" exit 2>/dev/null; then
            log "INFO" "SSH connection to ${vps_name} successful"
            return 0
        else
            log "ERROR" "SSH connection to ${vps_name} (${ip}) failed"
            return 1
        fi
    else
        # macOS doesn't have timeout by default, use SSH ConnectTimeout only
        if ssh -o ConnectTimeout=${SSH_TIMEOUT} \
           -o BatchMode=yes -o StrictHostKeyChecking=no \
           "$vps_host" exit 2>/dev/null; then
            log "INFO" "SSH connection to ${vps_name} successful"
            return 0
        else
            log "ERROR" "SSH connection to ${vps_name} (${ip}) failed"
            return 1
        fi
    fi
}

# Get tunnel uptime
get_tunnel_uptime() {
    local port=$1
    local pid=$(lsof -iTCP:${port} -sTCP:LISTEN -t 2>/dev/null | head -n1)
    
    if [[ -z "$pid" ]]; then
        echo "N/A"
        return 1
    fi
    
    # Try to get elapsed time directly (Linux)
    local etime=$(ps -p "$pid" -o etime= 2>/dev/null | tr -d ' ')
    if [[ -n "$etime" ]] && [[ "$etime" != "ELAPSED" ]]; then
        echo "$etime"
        return 0
    fi
    
    # Fallback: calculate from start time (macOS)
    local start_time=$(ps -p "$pid" -o lstart= 2>/dev/null | tr -s ' ')
    if [[ -n "$start_time" ]]; then
        # Parse format: "Mon Jan 1 12:00:00 2024" or "Mon Jan  1 12:00:00 2024"
        local start_epoch=$(date -j -f "%a %b %d %H:%M:%S %Y" "$start_time" "+%s" 2>/dev/null)
        if [[ -z "$start_epoch" ]]; then
            # Try alternative format with single digit day
            start_epoch=$(date -j -f "%a %b  %d %H:%M:%S %Y" "$start_time" "+%s" 2>/dev/null)
        fi
        
        if [[ -n "$start_epoch" ]]; then
            local now_epoch=$(date "+%s")
            local uptime_seconds=$((now_epoch - start_epoch))
            
            if [[ $uptime_seconds -lt 0 ]]; then
                echo "N/A"
                return 1
            fi
            
            local days=$((uptime_seconds / 86400))
            local hours=$(((uptime_seconds % 86400) / 3600))
            local minutes=$(((uptime_seconds % 3600) / 60))
            
            if [[ $days -gt 0 ]]; then
                echo "${days}d ${hours}h ${minutes}m"
            elif [[ $hours -gt 0 ]]; then
                echo "${hours}h ${minutes}m"
            else
                echo "${minutes}m"
            fi
            return 0
        fi
    fi
    
    echo "N/A"
    return 1
}

# Find config by service name or port
find_config() {
    local search_term=$1
    local found_configs=()
    
    for config in "${VPS_CONFIGS[@]}"; do
        local vps_name user ip service_name icon local_port remote_host remote_port
        if parse_config "$config" vps_name user ip service_name icon local_port remote_host remote_port; then
            if [[ "$service_name" == "$search_term" ]] || \
               [[ "$local_port" == "$search_term" ]] || \
               [[ "${service_name}" =~ "$search_term" ]]; then
                found_configs+=("$config")
            fi
        fi
    done
    
    echo "${found_configs[@]}"
}

# =============================================================================
# Main Functions
# =============================================================================

# Filter function to remove debug output lines
filter_debug() {
    grep -v "^vps_name=" | \
    grep -v "^user=" | \
    grep -v "^ip=" | \
    grep -v "^service_name=" | \
    grep -v "^icon=" | \
    grep -v "^local_port=" | \
    grep -v "^remote_host=" | \
    grep -v "^remote_port=" | \
    grep -v "^_vps_name=" | \
    grep -v "^_user=" | \
    grep -v "^_ip=" | \
    grep -v "^_service_name=" | \
    grep -v "^_icon=" | \
    grep -v "^_local_port=" | \
    grep -v "^_remote_host=" | \
    grep -v "^_remote_port="
}

# Connect to databases via SSH tunnels
connect_db() {
    local service_filter=$1  # Optional: connect to specific service
    
    {
        echo "üîå Establishing database connections..."
        [[ -n "$service_filter" ]] && echo "   Filter: $service_filter"
        echo ""
        
        local already_connected=0
        local newly_connected=0
        local failed_connections=0
        local skipped_invalid=0
        
        # Filter configs if service_filter is provided
        local configs_to_process=()
        if [[ -n "$service_filter" ]]; then
            local found_configs=($(find_config "$service_filter"))
            if [[ ${#found_configs[@]} -eq 0 ]]; then
                echo "‚ùå No service found matching: $service_filter"
                echo "üí° Use -l to list all available services"
                return 1
            fi
            configs_to_process=("${found_configs[@]}")
        else
            configs_to_process=("${VPS_CONFIGS[@]}")
        fi
        
        # Check each port and connect if not already connected
        typeset -A vps_groups
        typeset -A ports_to_connect
        
        for config in "${configs_to_process[@]}"; do
            local vps_name user ip service_name icon local_port remote_host remote_port
            
            # Parse config and suppress debug output
            {
                if ! parse_config "$config" vps_name user ip service_name icon local_port remote_host remote_port; then
                    ((skipped_invalid++))
                    continue
                fi
            } 2>/dev/null
        
        if is_port_in_use "${local_port}"; then
            if is_our_ssh_tunnel "${local_port}"; then
                echo "‚è≠Ô∏è  ${icon} ${service_name} (port ${local_port}): Already connected, skipping..."
                ((already_connected++))
            else
                local process_info=$(get_port_process_info "${local_port}")
                echo "‚ö†Ô∏è  ${icon} ${service_name} (port ${local_port}): Port in use by other process"
                echo "   ${process_info}"
                log "WARN" "Port ${local_port} is in use by another process: ${process_info}"
                ((failed_connections++))
            fi
        else
            # Mark this port for connection
            local vps_key="${vps_name}|${user}|${ip}"
            if [[ -z "${vps_groups[$vps_key]}" ]]; then
                vps_groups[$vps_key]="$config"
            else
                vps_groups[$vps_key]+=";$config"
            fi
            ports_to_connect[$local_port]=1
        fi
    done
    
    # Establish SSH tunnels for ports that need connection
    if [[ ${#vps_groups[@]} -gt 0 ]]; then
        for vps_key in ${(k)vps_groups}; do
            IFS='|' read -r vps_name user ip <<< "$vps_key"
            local vps_host="${user}@${ip}"
            
            echo "üì° Connecting to services via ${vps_name} (${ip})..."
            
            # Test SSH connection first (optional, skip if test fails but still try to connect)
            # SSH will fail on its own if connection is not possible
            if ! test_ssh_connection "$user" "$ip" "$vps_name"; then
                echo "‚ö†Ô∏è  SSH test failed for ${vps_name}, but will still attempt connection..."
            fi
            
            # Build SSH command using array (safe, no eval)
            local ssh_args=("-f" "-N" "-o" "ConnectTimeout=${SSH_TIMEOUT}" "-o" "ServerAliveInterval=60" "-o" "ServerAliveCountMax=3")
            local services=()
            IFS=';' read -rA configs <<< "${vps_groups[$vps_key]}"
            
            for config in "${configs[@]}"; do
                local _vps_name _user _ip service_name icon local_port remote_host remote_port
                {
                    parse_config "$config" _vps_name _user _ip service_name icon local_port remote_host remote_port
                } 2>/dev/null
                ssh_args+=("-L" "${local_port}:${remote_host}:${remote_port}")
                services+=("   ${icon} ${service_name}: localhost:${local_port}")
            done
            
            ssh_args+=("${vps_host}")
            
            # Execute SSH tunnel using array (safe)
            local ssh_output
            ssh_output=$(ssh "${ssh_args[@]}" 2>&1)
            local ssh_exit_code=$?
            
            if [[ $ssh_exit_code -eq 0 ]]; then
                echo "‚úÖ Tunnels established:"
                for service_info in "${services[@]}"; do
                    echo "$service_info"
                    ((newly_connected++))
                done
                echo ""
                log "INFO" "Successfully established tunnels to ${vps_name}"
            else
                echo "‚ùå Failed to establish tunnels to ${vps_name}"
                if [[ -n "$ssh_output" ]]; then
                    echo "   Error: $ssh_output"
                else
                    echo "üí° Check SSH connection, authentication, or if ports are already in use"
                fi
                ((failed_connections+=${#services[@]}))
                log "ERROR" "Failed to establish tunnels to ${vps_name}: $ssh_output"
            fi
        done
    fi
    
        # Display analytics
        echo ""
        # echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo "üìä CONNECTION ANALYTICS"
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo "‚úÖ Already connected: ${already_connected}"
        echo "üÜï Newly connected:   ${newly_connected}"
        echo "‚ùå Failed:            ${failed_connections}"
        [[ $skipped_invalid -gt 0 ]] && echo "‚ö†Ô∏è  Invalid configs:    ${skipped_invalid}"
        echo "üìà Total services:    $((already_connected + newly_connected))"
        # echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo ""
    } 2>&1 | filter_debug
}

# Disconnect all database tunnels
disconnect_db() {
    local service_filter=$1  # Optional: disconnect specific service
    
    {
        echo "üîå Closing database tunnels..."
        [[ -n "$service_filter" ]] && echo "   Filter: $service_filter"
        echo ""
        
        local disconnected=0
        local not_connected=0
        local failed_disconnect=0
        
        # Filter configs if service_filter is provided
        local configs_to_process=()
        if [[ -n "$service_filter" ]]; then
            local found_configs=($(find_config "$service_filter"))
            if [[ ${#found_configs[@]} -eq 0 ]]; then
                echo "‚ùå No service found matching: $service_filter"
                echo "üí° Use -l to list all available services"
                return 1
            fi
            configs_to_process=("${found_configs[@]}")
        else
            configs_to_process=("${VPS_CONFIGS[@]}")
        fi
        
        # Group ports by PID to avoid killing the same SSH process multiple times
        # (multiple ports can be forwarded by the same SSH command)
        typeset -A pid_to_ports
        typeset -A port_to_service
        
        # First pass: collect all ports and their PIDs
        for config in "${configs_to_process[@]}"; do
            local vps_name user ip service_name icon local_port remote_host remote_port
            
            # Parse config and suppress debug output
            {
                if ! parse_config "$config" vps_name user ip service_name icon local_port remote_host remote_port; then
                    continue
                fi
            } 2>/dev/null
        
        # Find PID by port (more reliable than pattern matching)
        local pid=$(lsof -iTCP:${local_port} -sTCP:LISTEN -t 2>/dev/null | head -n1)
        
        if [[ -n "$pid" ]]; then
            # Verify it's an SSH process
            local cmd=$(ps -p "$pid" -o command= 2>/dev/null)
            if echo "$cmd" | grep -q "ssh.*-L.*${local_port}"; then
                # Group ports by PID
                if [[ -z "${pid_to_ports[$pid]}" ]]; then
                    pid_to_ports[$pid]="${local_port}"
                else
                    pid_to_ports[$pid]+=" ${local_port}"
                fi
                port_to_service[$local_port]="${icon}|${service_name}"
            else
                echo "‚ö†Ô∏è  ${icon} ${service_name} (port ${local_port}): Port in use by non-SSH process"
                ((not_connected++))
            fi
        else
            echo "‚ÑπÔ∏è  ${icon} ${service_name} (port ${local_port}): Not connected"
            ((not_connected++))
        fi
    done
    
    # Second pass: kill PIDs (each PID may handle multiple ports)
    for pid in ${(k)pid_to_ports}; do
        local ports=(${=pid_to_ports[$pid]})
        local services_info=()
        
        for port in "${ports[@]}"; do
            IFS='|' read -r icon service_name <<< "${port_to_service[$port]}"
            services_info+=("${icon} ${service_name} (port ${port})")
        done
        
        # Kill the process
        if kill "$pid" 2>/dev/null; then
            # Wait a bit and verify it's actually killed
            sleep 0.5
            if ! kill -0 "$pid" 2>/dev/null; then
                echo "‚úÖ Disconnected ${#ports[@]} service(s):"
                for service_info in "${services_info[@]}"; do
                    echo "   - ${service_info}"
                    ((disconnected++))
                done
                log "INFO" "Disconnected PID $pid (ports: ${ports[@]})"
            else
                echo "‚ö†Ô∏è  Process still running, trying force kill..."
                kill -9 "$pid" 2>/dev/null
                sleep 0.5
                if ! kill -0 "$pid" 2>/dev/null; then
                    echo "‚úÖ Force disconnected ${#ports[@]} service(s):"
                    for service_info in "${services_info[@]}"; do
                        echo "   - ${service_info}"
                        ((disconnected++))
                    done
                else
                    echo "‚ùå Failed to disconnect ${#ports[@]} service(s):"
                    for service_info in "${services_info[@]}"; do
                        echo "   - ${service_info}"
                        ((failed_disconnect++))
                    done
                fi
            fi
        else
            echo "‚ùå Failed to disconnect ${#ports[@]} service(s) (permission denied?):"
            for service_info in "${services_info[@]}"; do
                echo "   - ${service_info}"
                ((failed_disconnect++))
            done
        fi
    done
    
        # Display analytics
        echo ""
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo "üìä DISCONNECTION ANALYTICS"
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo "‚úÖ Disconnected:     ${disconnected}"
        echo "‚ÑπÔ∏è  Not connected:    ${not_connected}"
        [[ $failed_disconnect -gt 0 ]] && echo "‚ùå Failed:            ${failed_disconnect}"
        echo "üìà Total services:   $((disconnected + not_connected + failed_disconnect))"
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo ""
    } 2>&1 | filter_debug
}

# Show all forwarded ports
show_forward_port() {
    # Disable any debug/trace output
    set +x 2>/dev/null
    
    {
        echo ""
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo "                                    üìä PORT FORWARD STATUS"
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo ""
        
        local connected=0
        local not_connected=0
        local invalid_configs=0
        
        # Print table header with proper spacing
        printf "%-3s  %-18s  %-15s  %-22s  %-15s  %-10s\n" "STAT" "SERVICE" "LOCAL PORT" "REMOTE" "VIA" "UPTIME"
        echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
        
        # Process all services and display in table format
        for config in "${VPS_CONFIGS[@]}"; do
            local vps_name user ip service_name icon local_port remote_host remote_port
            
            # Parse config - suppress stderr but debug output might go to stdout
            if ! parse_config "$config" vps_name user ip service_name icon local_port remote_host remote_port 2>/dev/null; then
                ((invalid_configs++))
                continue
            fi
            
            local status_icon=""
            local uptime=""
            local remote_info="${remote_host}:${remote_port}"
            
            if is_port_in_use "${local_port}"; then
                if is_our_ssh_tunnel "${local_port}"; then
                    status_icon="üü¢"
                    uptime=$(get_tunnel_uptime "${local_port}" 2>/dev/null)
                    ((connected++))
                else
                    status_icon="‚ö†Ô∏è"
                    uptime="Other"
                fi
            else
                status_icon="üî¥"
                uptime="-"
                ((not_connected++))
            fi
            
            # Prepare display values (no truncation needed with better column widths)
            local display_service="${icon} ${service_name}"
            local display_local="localhost:${local_port}"
            local display_remote="${remote_info}"
            local display_via="${vps_name}"
            
            # Print single row per service only - this is the ONLY output for each service
            printf "%-3s  %-18s  %-15s  %-22s  %-15s  %-10s\n" \
                "${status_icon}" \
                "${display_service}" \
                "${display_local}" \
                "${display_remote}" \
                "${display_via}" \
                "${uptime}"
        done
        
        echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
        
        # Display analytics
        echo ""
        echo "üìä SUMMARY: üü¢ ${connected} connected  |  üî¥ ${not_connected} not connected"
        [[ $invalid_configs -gt 0 ]] && echo "‚ö†Ô∏è  ${invalid_configs} invalid config(s)"
        echo ""
        
        if [[ $connected -eq 0 ]] && [[ $not_connected -gt 0 ]]; then
            echo "üí° Run 'db_connection_tool -c' to establish connections"
            echo ""
        fi
    } 2>&1 | filter_debug
}

# Test SSH connectivity to all VPS
test_connections() {
    {
        echo "üß™ Testing SSH connectivity to all VPS..."
        echo ""
        
        local success=0
        local failed=0
        typeset -A vps_hosts
        
        # Collect unique VPS hosts
        for config in "${VPS_CONFIGS[@]}"; do
            local vps_name user ip service_name icon local_port remote_host remote_port
            
            # Parse config and suppress debug output
            {
                if ! parse_config "$config" vps_name user ip service_name icon local_port remote_host remote_port; then
                    continue
                fi
            } 2>/dev/null
            
            local vps_key="${vps_name}|${user}|${ip}"
            if [[ -z "${vps_hosts[$vps_key]}" ]]; then
                vps_hosts[$vps_key]="${user}|${ip}"
            fi
        done
        
        # Test each VPS
        for vps_key in ${(k)vps_hosts}; do
            IFS='|' read -r vps_name user ip <<< "$vps_key"
            
            echo -n "Testing ${vps_name} (${ip})... "
            echo ""
            if test_ssh_connection "$user" "$ip" "$vps_name"; then
                echo "‚úÖ OK"
                ((success++))
            else
                echo "‚ùå FAILED"
                ((failed++))
            fi
        done
        
        echo ""
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo "üìä TEST RESULTS"
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo "‚úÖ Successful:       ${success}"
        echo "‚ùå Failed:           ${failed}"
        echo "üìà Total VPS:        $((success + failed))"
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo ""
    } 2>&1 | filter_debug
}

# Show usage information
show_usage() {
    echo "Usage: db_connection_tool [OPTIONS] [SERVICE_NAME]"
    echo ""
    echo "Options:"
    echo "  -c, --connect [SERVICE]    Connect to all databases (or specific service)"
    echo "  -d, --disconnect [SERVICE]  Disconnect all tunnels (or specific service)"
    echo "  -l, --list                 Show active port forwards"
    echo "  -t, --test                 Test SSH connectivity to all VPS"
    echo "  -h, --help                 Show this help message"
    echo ""
    echo "Examples:"
    echo "  db_connection_tool -c                    # Connect to all services"
    echo "  db_connection_tool -c postgres           # Connect to postgres service only"
    echo "  db_connection_tool -d 5432               # Disconnect service on port 5432"
    echo "  db_connection_tool -l                    # List all port forwards"
    echo "  db_connection_tool -t                    # Test SSH connections"
    echo ""
}

# Main database connection tool function
db_connection_tool() {
    # Parse command line arguments
    typeset service_filter=""
    typeset action=""
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -c|--connect)
                action="connect"
                if [[ -n "$2" ]] && [[ ! "$2" =~ ^- ]]; then
                    service_filter="$2"
                    shift
                fi
                shift
                ;;
            -d|--disconnect)
                action="disconnect"
                if [[ -n "$2" ]] && [[ ! "$2" =~ ^- ]]; then
                    service_filter="$2"
                    shift
                fi
                shift
                ;;
            -l|--list)
                action="list"
                shift
                ;;
            -t|--test)
                action="test"
                shift
                ;;
            -h|--help)
                action="help"
                shift
                ;;
            *)
                if [[ -z "$action" ]]; then
                    echo "‚ùå Unknown option: $1"
                    echo ""
                    show_usage
                    return 1
                else
                    # This might be a service filter for a previous action
                    service_filter="$1"
                    shift
                fi
                ;;
        esac
    done
    
    # Execute action
    case "$action" in
        connect)
            connect_db "$service_filter"
            return $?
            ;;
        disconnect)
            disconnect_db "$service_filter"
            return $?
            ;;
        list)
            show_forward_port
            return 0
            ;;
        test)
            test_connections
            return $?
            ;;
        help)
            show_usage
            return 0
            ;;
        *)
            show_usage
            return 1
            ;;
    esac
}

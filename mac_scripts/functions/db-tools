#!/bin/zsh

# =============================================================================
# Database Tool - Unified Database Connection & Sync Manager
# =============================================================================

# Global variables
typeset -g SSH_TIMEOUT=10

# Find secrets file - prioritize source code root, fallback to iCloud
find_secrets_file() {
    # Try to find root of source code (where mac_scripts_secrets.example is located)
    # Start from script directory and go up to find the root
    local current_dir="$(cd "$(dirname "${BASH_SOURCE[0]:-$0}")" && pwd)"
    local root_dir=""
    
    # Look for mac_scripts_secrets.example to identify root
    while [[ "$current_dir" != "/" ]]; do
        if [[ -f "$current_dir/mac_scripts_secrets.example" ]]; then
            root_dir="$current_dir"
            break
        fi
        current_dir="$(dirname "$current_dir")"
    done
    
    # First priority: source code root
    if [[ -n "$root_dir" ]] && [[ -f "$root_dir/mac_scripts_secrets" ]]; then
        echo "$root_dir/mac_scripts_secrets"
        return 0
    fi
    
    # Second priority: iCloud Drive
    local icloud_drive_root="${HOME}/Library/Mobile Documents/com~apple~CloudDocs"
    local icloud_secrets="${icloud_drive_root}/Backups/mac_scripts_secrets"
    if [[ -f "$icloud_secrets" ]]; then
        echo "$icloud_secrets"
        return 0
    fi
    
    # Not found
    return 1
}

# Auto-load VPS configurations from secrets file
# This ensures we always use the latest configurations
{
    local secrets_file
    if secrets_file=$(find_secrets_file 2>/dev/null); then
        # Source secrets file and suppress all output (including debug output)
        {
            source "$secrets_file" 2>/dev/null
        } >/dev/null 2>&1
        
        if [[ -z "${VPS_CONFIGS[@]}" ]]; then
            echo "âš ï¸  Warning: VPS_CONFIGS not found in secrets file"
            echo "   Please define VPS_CONFIGS array in $secrets_file"
            typeset -a VPS_CONFIGS=()
        fi
    else
        echo "âš ï¸  Warning: Secrets file not found"
        echo "   Please create mac_scripts_secrets in source root or iCloud Drive"
        typeset -a VPS_CONFIGS=()
    fi
}

# =============================================================================
# Shared Utility Functions
# =============================================================================

# Load secrets from secrets file
load_secrets() {
    local secrets_file
    if ! secrets_file=$(find_secrets_file 2>/dev/null); then
        echo "âš ï¸  Warning: Secrets file not found"
        echo "   Please create mac_scripts_secrets in source root or iCloud Drive"
        export VPS_CONFIGS=()
        export POSTGRES_SOURCES=()
        export POSTGRES_TARGETS=()
        export MONGO_SOURCES=()
        export MONGO_TARGETS=()
        return 1
    fi
    
    # Source secrets file - suppress all output like db_connection_tool does
    {
        source "$secrets_file" 2>/dev/null
    } >/dev/null 2>&1
    
    # Export arrays as global variables to ensure they're available outside this function
    if [[ -n "${VPS_CONFIGS[@]}" ]]; then
        export VPS_CONFIGS=("${VPS_CONFIGS[@]}")
    else
        export VPS_CONFIGS=()
    fi
    
    if [[ -n "${POSTGRES_SOURCES[@]}" ]]; then
        export POSTGRES_SOURCES=("${POSTGRES_SOURCES[@]}")
    else
        export POSTGRES_SOURCES=()
    fi
    
    if [[ -n "${POSTGRES_TARGETS[@]}" ]]; then
        export POSTGRES_TARGETS=("${POSTGRES_TARGETS[@]}")
    else
        export POSTGRES_TARGETS=()
    fi
    
    if [[ -n "${MONGO_SOURCES[@]}" ]]; then
        export MONGO_SOURCES=("${MONGO_SOURCES[@]}")
    else
        export MONGO_SOURCES=()
    fi
    
    if [[ -n "${MONGO_TARGETS[@]}" ]]; then
        export MONGO_TARGETS=("${MONGO_TARGETS[@]}")
    else
        export MONGO_TARGETS=()
    fi
    
    # Warn if no configs found
    if [[ ${#VPS_CONFIGS[@]} -eq 0 ]] && [[ ${#POSTGRES_SOURCES[@]} -eq 0 ]] && [[ ${#MONGO_SOURCES[@]} -eq 0 ]]; then
        echo "âš ï¸  Warning: No configurations found in secrets file"
        echo "   Please define VPS_CONFIGS, POSTGRES_SOURCES, and/or MONGO_SOURCES in $secrets_file"
    fi
}

# Log message to stdout
log() {
    local level=$1
    shift
    local message="$@"
    
    if [[ "$level" == "ERROR" ]]; then
        echo "âŒ $message" >&2
    elif [[ "$level" == "WARN" ]]; then
        echo "âš ï¸  $message"
    elif [[ "$level" == "INFO" ]]; then
        echo "â„¹ï¸  $message"
    fi
}

# =============================================================================
# Main Function - Command Router
# =============================================================================

# Show usage information
show_db_tools_usage() {
    # ANSI color codes
    local reset='\033[0m'
    local bold='\033[1m'
    local cyan='\033[0;36m'
    local green='\033[0;32m'
    local yellow='\033[1;33m'
    local blue='\033[0;34m'
    local magenta='\033[0;35m'
    local gray='\033[0;90m'
    
    echo -e "${bold}${cyan}ğŸ—„ï¸  Database Tool - Unified Database Connection & Sync Manager${reset}"
    echo ""
    echo -e "${bold}This tool provides unified management for:${reset}"
    echo -e "  ${green}â€¢${reset} SSH tunnels to connect to remote database services"
    echo -e "  ${green}â€¢${reset} Synchronizing PostgreSQL and MongoDB databases"
    echo ""
    echo -e "${bold}${yellow}Secrets file lookup priority:${reset}"
    echo -e "  ${cyan}1.${reset} Source code root (same directory as mac_scripts_secrets.example)"
    echo -e "  ${cyan}2.${reset} iCloud Drive: ~/Library/Mobile Documents/com~apple~CloudDocs/Backups/mac_scripts_secrets"
    echo ""
    echo -e "For secrets file format, see: ${cyan}mac_scripts_secrets.example${reset}"
    echo ""
    echo -e "${bold}${blue}COMMANDS:${reset}"
    echo -e "  ${green}dbt connect${reset} [SERVICE]                    ${gray}# Connect to databases via SSH tunnels${reset}"
    echo -e "                                             ${gray}[SERVICE]: Optional service name or local port to filter${reset}"
    echo -e "  ${green}dbt disconnect${reset} [SERVICE]                 ${gray}# Disconnect SSH tunnels${reset}"
    echo -e "                                             ${gray}[SERVICE]: Optional service name or local port to filter${reset}"
    echo -e "  ${green}dbt ls|list${reset} [--status]                   ${gray}# Show connections${reset}"
    echo -e "  ${green}dbt test${reset}                                 ${gray}# Test SSH connectivity to all VPS${reset}"
    echo -e "  ${green}dbt sync ls|list${reset} [--status]              ${gray}# Show sync configurations${reset}"
    echo -e "                                             ${gray}--status: Check connection status for sync configs${reset}"
    echo -e "  ${green}dbt sync postgres${reset} -s <idx> -d <idx>      ${gray}# Sync PostgreSQL database${reset}"
    echo -e "  ${green}dbt sync postgres${reset} ... --verbose          ${gray}# PostgreSQL sync with detailed progress${reset}"
    echo -e "  ${green}dbt sync mongodb${reset} -s <idx> -d <idx>       ${gray}# Sync MongoDB database${reset}"
    echo ""
    echo -e "${bold}${blue}SYNC FLAGS:${reset}"
    echo -e "  ${green}--source, -s${reset} <index>       Source index (1-based)"
    echo -e "  ${green}--database, -db${reset} <index>    Database index (default: 1)"
    echo -e "  ${green}--destination, -d${reset} <index>  Destination index (1-based)"
    echo ""
    echo -e "${bold}${blue}EXAMPLES:${reset}"
    echo -e "  ${green}dbt connect${reset}                              ${gray}# Connect to all services${reset}"
    echo -e "  ${green}dbt connect postgres${reset}                     ${gray}# Connect to postgres service only${reset}"
    echo -e "  ${green}dbt connect 5432${reset}                         ${gray}# Connect to service on local port 5432${reset}"
    echo -e "  ${green}dbt disconnect postgres${reset}                  ${gray}# Disconnect postgres service${reset}"
    echo -e "  ${green}dbt ls|list${reset}                              ${gray}# List connections${reset}"
    echo -e "  ${green}dbt sync ls|list${reset}                         ${gray}# List sync configurations${reset}"
    echo -e "  ${green}dbt sync ls|list --status${reset}                ${gray}# List sync configs with status${reset}"
    echo -e "  ${green}dbt sync postgres -s 1 -d 1${reset}              ${gray}# Sync PostgreSQL${reset}"
    echo -e "  ${green}dbt sync postgres -s 1 -d 1 --verbose${reset}    ${gray}# Sync PostgreSQL with detailed progress${reset}"
    echo -e "  ${green}dbt sync postgres -s 1 -db 1 -d 2${reset}        ${gray}# Sync PostgreSQL with database${reset}"
    echo -e "  ${green}dbt sync mongodb -s 1 -d 1${reset}               ${gray}# Sync MongoDB${reset}"
    echo ""
}

# Main database tool function
db_tools() {
    # Load secrets first
    load_secrets
    
    local command="$1"
    shift
    
    case "$command" in
        connect)
            db_tools_connect "$@"
            ;;
        disconnect)
            db_tools_disconnect "$@"
            ;;
        list|ls)
            db_tools_list "$@"
            ;;
        test)
            db_tools_test "$@"
            ;;
        sync)
            db_tools_sync "$@"
            ;;
        --help|-h|help|"")
            show_db_tools_usage
            ;;
        *)
            echo "âŒ Unknown command: $command"
            echo "ğŸ’¡ Available commands: connect, disconnect, list|ls, test, sync"
            echo "ğŸ’¡ Use 'dbt --help' for usage information"
            return 1
            ;;
    esac
}

# Connection commands
db_tools_connect() {
    local service_filter="$1"
    connect_db "$service_filter"
}

db_tools_disconnect() {
    local service_filter="$1"
    disconnect_db "$service_filter"
}

db_tools_list() {
    # Ensure secrets are loaded
    load_secrets
    
    # Parse flags
    local check_status=false
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --status)
                check_status=true
                shift
                ;;
            *)
                echo "âŒ Unknown option: $1"
                echo "ğŸ’¡ Use: dbt list [--status]"
                return 1
                ;;
        esac
    done
    
    # Show only connections
    echo ""
    echo "ğŸ”Œ Connections"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    show_forward_port
    echo ""
}

db_tools_test() {
    test_connections
}

# Sync list command - show only sync configurations
db_tools_sync_list() {
    # Ensure secrets are loaded
    load_secrets
    
    # Parse flags
    local check_status=false
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --status)
                check_status=true
                shift
                ;;
            *)
                echo "âŒ Unknown option: $1"
                echo "ğŸ’¡ Use: dbt sync ls|list [--status]"
                return 1
                ;;
        esac
    done
    
    # Show only sync configurations
    echo ""
    echo "ğŸ—„ï¸  Sync Configurations"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    list_all_configs "$check_status"
    echo ""
}

# Sync command
db_tools_sync() {
    local sync_type="$1"
    shift
    
    case "$sync_type" in
        postgres|postgresql|pg)
            db_tools_sync_postgres "$@"
            ;;
        mongodb)
            db_tools_sync_mongodb "$@"
            ;;
        ls|list)
            db_tools_sync_list "$@"
            ;;
        *)
            echo "âŒ Unknown sync type: $sync_type"
            echo "ğŸ’¡ Use: dbt sync [postgres|mongodb] --source <idx> --destination <idx>"
            echo "ğŸ’¡ Or: dbt sync [postgres|mongodb] -s <idx> -d <idx> (short flags)"
            echo "ğŸ’¡ Or: dbt sync ls|list [--status] to list sync configurations"
            return 1
            ;;
    esac
}

# Parse sync flags (support both long and short versions)
db_tools_sync_postgres() {
    # Load secrets first to ensure configuration arrays are available
    load_secrets
    
    local source_idx=""
    local db_idx=""
    local dest_idx=""
    local verbose_mode="false"
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --source|-s)
                source_idx="$2"
                shift 2
                ;;
            --database|-db)
                db_idx="$2"
                shift 2
                ;;
            --destination|-d)
                dest_idx="$2"
                shift 2
                ;;
            --verbose|-v)
                verbose_mode="true"
                shift
                ;;
            *)
                echo "âŒ Unknown option: $1"
                echo "ğŸ’¡ Use: dbt sync postgres --source <idx> --destination <idx> [--verbose]"
                return 1
                ;;
        esac
    done
    
    # Validate required flags
    if [[ -z "$source_idx" ]] || [[ -z "$dest_idx" ]]; then
        echo "âŒ Error: PostgreSQL sync requires --source and --destination flags"
        echo "   Use 'dbt list' to list available configurations"
        return 1
    fi
    
    # Default database index to 1 if not specified
    db_idx=${db_idx:-1}
    
    # Validate source
    local source_config=$(get_postgres_source_config "$source_idx")
    if [[ -z "$source_config" ]]; then
        echo "âŒ Error: Invalid PostgreSQL source index: $source_idx"
        echo "   Available sources: 1-${#POSTGRES_SOURCES[@]}"
        return 1
    fi
    
    # Validate destination
    local dest_config=$(get_postgres_target_config "$dest_idx")
    if [[ -z "$dest_config" ]]; then
        echo "âŒ Error: Invalid PostgreSQL destination index: $dest_idx"
        echo "   Available destinations: 1-${#POSTGRES_TARGETS[@]}"
        return 1
    fi
    
    # Get database
    local source_db=$(get_postgres_source_database "$source_idx")
    if [[ -z "$source_db" ]]; then
        echo "âŒ Error: Invalid database index: $db_idx"
        return 1
    fi
    
    # Parse configs
    IFS='|' read -r source_name source_url _ <<< "$source_config"
    IFS='|' read -r dest_name dest_url <<< "$dest_config"
    
    # Show configuration and sync
    echo ""
    echo "ğŸ˜ PostgreSQL Sync"
    echo "=================="
    echo "  From: ${source_name} â†’ Database: ${source_db}"
    echo "  To: ${dest_name}"
    echo ""
    
    perform_postgres_sync "$source_url" "$source_db" "$dest_url" "false" "$verbose_mode"
}

db_tools_sync_mongodb() {
    # Load secrets first to ensure configuration arrays are available
    load_secrets
    
    local source_idx=""
    local db_idx=""
    local dest_idx=""
    local verbose_mode="false"
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --source|-s)
                source_idx="$2"
                shift 2
                ;;
            --database|-db)
                db_idx="$2"
                shift 2
                ;;
            --destination|-d)
                dest_idx="$2"
                shift 2
                ;;
            --verbose|-v)
                verbose_mode="true"
                shift
                ;;
            *)
                echo "âŒ Unknown option: $1"
                echo "ğŸ’¡ Use: dbt sync mongodb --source <idx> --destination <idx> [--verbose]"
                return 1
                ;;
        esac
    done
    
    # Validate required flags
    if [[ -z "$source_idx" ]] || [[ -z "$dest_idx" ]]; then
        echo "âŒ Error: MongoDB sync requires --source and --destination flags"
        echo "   Use 'dbt list' to list available configurations"
        return 1
    fi
    
    # Default database index to 1 if not specified
    db_idx=${db_idx:-1}
    
    # Validate source
    local source_config=$(get_mongodb_source_config "$source_idx")
    if [[ -z "$source_config" ]]; then
        echo "âŒ Error: Invalid MongoDB source index: $source_idx"
        echo "   Available sources: 1-${#MONGO_SOURCES[@]}"
        return 1
    fi
    
    # Validate destination
    local dest_config=$(get_mongodb_target_config "$dest_idx")
    if [[ -z "$dest_config" ]]; then
        echo "âŒ Error: Invalid MongoDB destination index: $dest_idx"
        echo "   Available destinations: 1-${#MONGO_TARGETS[@]}"
        return 1
    fi
    
    # Get database
    local source_db=$(get_mongodb_source_database "$source_idx" "$db_idx")
    if [[ -z "$source_db" ]]; then
        echo "âŒ Error: Invalid database index: $db_idx"
        return 1
    fi
    
    # Parse configs
    IFS='|' read -r source_name source_uri _ <<< "$source_config"
    IFS='|' read -r dest_name dest_uri <<< "$dest_config"
    
    # Show configuration and sync
    echo ""
    echo "ğŸƒ MongoDB Sync"
    echo "==============="
    echo "  From: ${source_name} â†’ Database: ${source_db}"
    echo "  To: ${dest_name} â†’ Database: ${source_db}"
    echo ""
    
    perform_mongo_sync "$source_uri" "$source_db" "${source_name}" "$dest_uri" "${dest_name}" "false" "$verbose_mode"
}

# Filter function to remove debug output lines
filter_debug() {
    grep -Ev '^(vps_name|user|ip|service_name|local_port|target_host|target_port|_vps_name|_user|_ip|_service_name|_local_port|_target_host|_target_port)='
}

# =============================================================================
# Connection Module - Utility Functions
# =============================================================================

# Parse config string into variables
# Returns 0 on success, 1 on failure
parse_config() {
    local config=$1
    local vps_name_var=$2
    local user_var=$3
    local ip_var=$4
    local service_name_var=$5
    local local_port_var=$6
    local target_host_var=$7
    local target_port_var=$8
    
    IFS='|' read -r vps_name user ip service_name local_port target_host target_port <<< "$config"
    
    # Validate config format (should have 7 fields)
    local field_count=$(echo "$config" | tr '|' '\n' | wc -l | tr -d ' ')
    if [[ $field_count -ne 7 ]]; then
        log "ERROR" "Invalid config format (expected 7 fields, got $field_count): $config"
        return 1
    fi
    
    # Validate port numbers
    if ! [[ "$local_port" =~ ^[0-9]+$ ]] || ! [[ "$target_port" =~ ^[0-9]+$ ]]; then
        log "ERROR" "Invalid port number in config: $config"
        return 1
    fi
    
    # Validate port range
    if [[ $local_port -lt 1 ]] || [[ $local_port -gt 65535 ]] || \
       [[ $target_port -lt 1 ]] || [[ $target_port -gt 65535 ]]; then
        log "ERROR" "Port out of range (1-65535) in config: $config"
        return 1
    fi
    
    # Set variables using eval (safe here as we control the variable names)
    eval "${vps_name_var}='${vps_name}'"
    eval "${user_var}='${user}'"
    eval "${ip_var}='${ip}'"
    eval "${service_name_var}='${service_name}'"
    eval "${local_port_var}='${local_port}'"
    eval "${target_host_var}='${target_host}'"
    eval "${target_port_var}='${target_port}'"
    
    return 0
}

# Check if a port is in use
is_port_in_use() {
    local port=$1
    if lsof -iTCP:${port} -sTCP:LISTEN -t > /dev/null 2>&1; then
        return 0  # Port is in use
    else
        return 1  # Port is free
    fi
}

# Get process info for a port
get_port_process_info() {
    local port=$1
    local pid=$(lsof -iTCP:${port} -sTCP:LISTEN -t 2>/dev/null | head -n1)
    
    if [[ -n "$pid" ]]; then
        local cmd=$(ps -p "$pid" -o command= 2>/dev/null | head -n1)
        echo "PID: $pid, CMD: ${cmd:0:60}"
    else
        echo "No process found"
    fi
}

# Check if port is used by our SSH tunnel
is_our_ssh_tunnel() {
    local port=$1
    local pid=$(lsof -iTCP:${port} -sTCP:LISTEN -t 2>/dev/null | head -n1)
    
    if [[ -n "$pid" ]]; then
        local cmd=$(ps -p "$pid" -o command= 2>/dev/null)
        if echo "$cmd" | grep -q "ssh.*-L.*${port}"; then
            return 0  # It's our tunnel
        fi
    fi
    return 1  # Not our tunnel
}

# Test SSH connectivity to a host
test_ssh_connection() {
    local user=$1
    local ip=$2
    local vps_name=$3
    local vps_host="${user}@${ip}"
    
    log "INFO" "Testing SSH connection to ${vps_name} (${ip})..."
    
    # Use timeout if available, otherwise use SSH's ConnectTimeout
    if command -v timeout >/dev/null 2>&1; then
        if timeout ${SSH_TIMEOUT} ssh -o ConnectTimeout=${SSH_TIMEOUT} \
           -o BatchMode=yes -o StrictHostKeyChecking=no \
           "$vps_host" exit 2>/dev/null; then
            log "INFO" "SSH connection to ${vps_name} successful"
            return 0
        else
            log "ERROR" "SSH connection to ${vps_name} (${ip}) failed"
            return 1
        fi
    else
        # macOS doesn't have timeout by default, use SSH ConnectTimeout only
        if ssh -o ConnectTimeout=${SSH_TIMEOUT} \
           -o BatchMode=yes -o StrictHostKeyChecking=no \
           "$vps_host" exit 2>/dev/null; then
            log "INFO" "SSH connection to ${vps_name} successful"
            return 0
        else
            log "ERROR" "SSH connection to ${vps_name} (${ip}) failed"
            return 1
        fi
    fi
}

# Get tunnel uptime
get_tunnel_uptime() {
    local port=$1
    local pid=$(lsof -iTCP:${port} -sTCP:LISTEN -t 2>/dev/null | head -n1)
    
    if [[ -z "$pid" ]]; then
        echo "N/A"
        return 1
    fi
    
    # Try to get elapsed time directly (Linux)
    local etime=$(ps -p "$pid" -o etime= 2>/dev/null | tr -d ' ')
    if [[ -n "$etime" ]] && [[ "$etime" != "ELAPSED" ]]; then
        echo "$etime"
        return 0
    fi
    
    # Fallback: calculate from start time (macOS)
    local start_time=$(ps -p "$pid" -o lstart= 2>/dev/null | tr -s ' ')
    if [[ -n "$start_time" ]]; then
        # Parse format: "Mon Jan 1 12:00:00 2024" or "Mon Jan  1 12:00:00 2024"
        local start_epoch=$(date -j -f "%a %b %d %H:%M:%S %Y" "$start_time" "+%s" 2>/dev/null)
        if [[ -z "$start_epoch" ]]; then
            # Try alternative format with single digit day
            start_epoch=$(date -j -f "%a %b  %d %H:%M:%S %Y" "$start_time" "+%s" 2>/dev/null)
        fi
        
        if [[ -n "$start_epoch" ]]; then
            local now_epoch=$(date "+%s")
            local uptime_seconds=$((now_epoch - start_epoch))
            
            if [[ $uptime_seconds -lt 0 ]]; then
                echo "N/A"
                return 1
            fi
            
            local days=$((uptime_seconds / 86400))
            local hours=$(((uptime_seconds % 86400) / 3600))
            local minutes=$(((uptime_seconds % 3600) / 60))
            
            if [[ $days -gt 0 ]]; then
                echo "${days}d ${hours}h ${minutes}m"
            elif [[ $hours -gt 0 ]]; then
                echo "${hours}h ${minutes}m"
            else
                echo "${minutes}m"
            fi
            return 0
        fi
    fi
    
    echo "N/A"
    return 1
}

# Find config by service name or port
find_config() {
    local search_term=$1
    local found_configs=()
    
    for config in "${VPS_CONFIGS[@]}"; do
        local vps_name user ip service_name local_port target_host target_port
        if parse_config "$config" vps_name user ip service_name local_port target_host target_port; then
            if [[ "$service_name" == "$search_term" ]] || \
               [[ "$local_port" == "$search_term" ]] || \
               [[ "${service_name}" =~ "$search_term" ]]; then
                found_configs+=("$config")
            fi
        fi
    done
    
    echo "${found_configs[@]}"
}

# Check if there are active connections
has_active_connections() {
    for config in "${VPS_CONFIGS[@]}"; do
        # Skip empty configs
        if [[ -z "$config" ]] || [[ "$config" =~ ^[[:space:]]*$ ]]; then
            continue
        fi
        
        local vps_name user ip service_name local_port target_host target_port
        # Parse config - don't use subshell
        if parse_config "$config" vps_name user ip service_name local_port target_host target_port 2>/dev/null; then
            if is_port_in_use "${local_port}" && is_our_ssh_tunnel "${local_port}"; then
                return 0
            fi
        fi
    done
    return 1
}

# =============================================================================
# Connection Module - Main Functions
# =============================================================================

# Connect to databases via SSH tunnels
connect_db() {
    # Load secrets first to ensure VPS_CONFIGS is available
    load_secrets
    
    local service_filter=$1  # Optional: connect to specific service
    
    {
        echo "ğŸ”Œ Establishing database connections..."
        [[ -n "$service_filter" ]] && echo "   Filter: $service_filter"
        echo ""
        
        local already_connected=0
        local newly_connected=0
        local failed_connections=0
        local skipped_invalid=0
        local invalid_configs_list=()
        
        # Filter configs if service_filter is provided
        local configs_to_process=()
        if [[ -n "$service_filter" ]]; then
            local found_configs=($(find_config "$service_filter"))
            if [[ ${#found_configs[@]} -eq 0 ]]; then
                echo "âŒ No service found matching: $service_filter"
                echo "ğŸ’¡ Use 'dbt list' to list all available services"
                return 1
            fi
            configs_to_process=("${found_configs[@]}")
        else
            configs_to_process=("${VPS_CONFIGS[@]}")
        fi
        
        # Check each port and connect if not already connected
        typeset -A vps_groups
        typeset -A ports_to_connect
        
        for config in "${configs_to_process[@]}"; do
            local vps_name user ip service_name local_port target_host target_port
            
            # Skip empty configs (from comments or blank lines)
            if [[ -z "$config" ]] || [[ "$config" =~ ^[[:space:]]*$ ]]; then
                continue
            fi
            
            # Parse config - don't use subshell to preserve variables
            local parse_error_file=$(mktemp)
            if ! parse_config "$config" vps_name user ip service_name local_port target_host target_port 2>"$parse_error_file"; then
                ((skipped_invalid++))
                invalid_configs_list+=("$config")
                # Show error for invalid config (filter debug output)
                local parse_error=$(cat "$parse_error_file" 2>/dev/null)
                if [[ -n "$parse_error" ]]; then
                    echo "$parse_error" | filter_debug >&2
                else
                    echo "âŒ Invalid config format: $config" >&2
                fi
                rm -f "$parse_error_file"
                continue
            fi
            rm -f "$parse_error_file"
        
        if is_port_in_use "${local_port}"; then
            if is_our_ssh_tunnel "${local_port}"; then
                echo "â­ï¸  ${service_name} (port ${local_port}): Already connected, skipping..."
                ((already_connected++))
            else
                local process_info=$(get_port_process_info "${local_port}")
                echo "âš ï¸  ${service_name} (port ${local_port}): Port in use by other process"
                echo "   ${process_info}"
                log "WARN" "Port ${local_port} is in use by another process: ${process_info}"
                ((failed_connections++))
            fi
        else
            # Validate parsed values before adding to groups
            if [[ -z "$vps_name" ]] || [[ -z "$user" ]] || [[ -z "$ip" ]] || [[ -z "$local_port" ]]; then
                echo "âš ï¸  Skipping invalid config (missing required fields): $config" >&2
                ((skipped_invalid++))
                invalid_configs_list+=("$config")
                continue
            fi
            
            # Mark this port for connection
            local vps_key="${vps_name}|${user}|${ip}"
            if [[ -z "${vps_groups[$vps_key]}" ]]; then
                vps_groups[$vps_key]="$config"
            else
                vps_groups[$vps_key]+=";$config"
            fi
            ports_to_connect[$local_port]=1
        fi
    done
    
    # Establish SSH tunnels for ports that need connection
    if [[ ${#vps_groups[@]} -gt 0 ]]; then
        for vps_key in ${(k)vps_groups}; do
            IFS='|' read -r vps_name user ip <<< "$vps_key"
            local vps_host="${user}@${ip}"
            
            echo "ğŸ“¡ Connecting to services via ${vps_name} (${ip})..."
            
            # Test SSH connection first (optional, skip if test fails but still try to connect)
            # SSH will fail on its own if connection is not possible
            if ! test_ssh_connection "$user" "$ip" "$vps_name"; then
                echo "âš ï¸  SSH test failed for ${vps_name}, but will still attempt connection..."
            fi
            
            # Build SSH command using array (safe, no eval)
            local ssh_args=("-f" "-N" "-o" "ConnectTimeout=${SSH_TIMEOUT}" "-o" "ServerAliveInterval=60" "-o" "ServerAliveCountMax=3")
            local services=()
            IFS=';' read -rA configs <<< "${vps_groups[$vps_key]}"
            
            for config in "${configs[@]}"; do
                local _vps_name _user _ip service_name local_port target_host target_port
                # Parse config - don't use subshell to preserve variables
                local parse_error_file=$(mktemp)
                if parse_config "$config" _vps_name _user _ip service_name local_port target_host target_port 2>"$parse_error_file"; then
                    ssh_args+=("-L" "${local_port}:${target_host}:${target_port}")
                    services+=("   ${service_name}: localhost:${local_port}")
                fi
                rm -f "$parse_error_file"
            done
            
            ssh_args+=("${vps_host}")
            
            # Execute SSH tunnel using array (safe)
            local ssh_output
            ssh_output=$(ssh "${ssh_args[@]}" 2>&1)
            local ssh_exit_code=$?
            
            if [[ $ssh_exit_code -eq 0 ]]; then
                echo "âœ… Tunnels established:"
                for service_info in "${services[@]}"; do
                    echo "$service_info"
                    ((newly_connected++))
                done
                echo ""
                log "INFO" "Successfully established tunnels to ${vps_name}"
            else
                echo "âŒ Failed to establish tunnels to ${vps_name}"
                if [[ -n "$ssh_output" ]]; then
                    echo "   Error: $ssh_output"
                else
                    echo "ğŸ’¡ Check SSH connection, authentication, or if ports are already in use"
                fi
                ((failed_connections+=${#services[@]}))
                log "ERROR" "Failed to establish tunnels to ${vps_name}: $ssh_output"
            fi
        done
    fi
    
        # Display analytics
        echo ""
        echo "ğŸ“Š CONNECTION ANALYTICS"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "âœ… Already connected: ${already_connected}"
        echo "ğŸ†• Newly connected:   ${newly_connected}"
        echo "âŒ Failed:            ${failed_connections}"
        if [[ $skipped_invalid -gt 0 ]]; then
            echo "âš ï¸  Invalid configs:    ${skipped_invalid}"
            echo ""
            echo "âŒ Invalid configuration(s) found:"
            local i=1
            for invalid_config in "${invalid_configs_list[@]}"; do
                echo "   ${i}) ${invalid_config}"
                ((i++))
            done
            echo ""
            echo "ğŸ’¡ Expected format: VPS_NAME|USER|IP|SERVICE_NAME|LOCAL_PORT|TARGET_HOST|TARGET_PORT"
            echo "ğŸ’¡ Check your secrets file for correct format"
        fi
        echo "ğŸ“ˆ Total services:    $((already_connected + newly_connected))"
        echo ""
    } 2>&1 | filter_debug
}

# Disconnect all database tunnels
disconnect_db() {
    # Load secrets first to ensure VPS_CONFIGS is available
    load_secrets
    
    local service_filter=$1  # Optional: disconnect specific service
    
    {
        echo "ğŸ”Œ Closing database tunnels..."
        [[ -n "$service_filter" ]] && echo "   Filter: $service_filter"
        echo ""
        
        local disconnected=0
        local not_connected=0
        local failed_disconnect=0
        
        # Filter configs if service_filter is provided
        local configs_to_process=()
        if [[ -n "$service_filter" ]]; then
            local found_configs=($(find_config "$service_filter"))
            if [[ ${#found_configs[@]} -eq 0 ]]; then
                echo "âŒ No service found matching: $service_filter"
                echo "ğŸ’¡ Use 'dbt list' to list all available services"
                return 1
            fi
            configs_to_process=("${found_configs[@]}")
        else
            configs_to_process=("${VPS_CONFIGS[@]}")
        fi
        
        # Group ports by PID to avoid killing the same SSH process multiple times
        # (multiple ports can be forwarded by the same SSH command)
        typeset -A pid_to_ports
        typeset -A port_to_service
        
        # First pass: collect all ports and their PIDs
        for config in "${configs_to_process[@]}"; do
            local vps_name user ip service_name local_port target_host target_port
            
            # Parse config and suppress debug output
            {
                if ! parse_config "$config" vps_name user ip service_name local_port target_host target_port; then
                    continue
                fi
            } 2>/dev/null
        
        # Find PID by port (more reliable than pattern matching)
        local pid=$(lsof -iTCP:${local_port} -sTCP:LISTEN -t 2>/dev/null | head -n1)
        
        if [[ -n "$pid" ]]; then
            # Verify it's an SSH process
            local cmd=$(ps -p "$pid" -o command= 2>/dev/null)
            if echo "$cmd" | grep -q "ssh.*-L.*${local_port}"; then
                # Group ports by PID
                if [[ -z "${pid_to_ports[$pid]}" ]]; then
                    pid_to_ports[$pid]="${local_port}"
                else
                    pid_to_ports[$pid]+=" ${local_port}"
                fi
                port_to_service[$local_port]="${service_name}"
            else
                echo "âš ï¸  ${service_name} (port ${local_port}): Port in use by non-SSH process"
                ((not_connected++))
            fi
        else
            echo "â„¹ï¸  ${service_name} (port ${local_port}): Disconnected"
            ((not_connected++))
        fi
    done
    
    # Second pass: kill PIDs (each PID may handle multiple ports)
    for pid in ${(k)pid_to_ports}; do
        local ports=(${=pid_to_ports[$pid]})
        local services_info=()
        
        for port in "${ports[@]}"; do
            local service_name="${port_to_service[$port]}"
            services_info+=("${service_name} (port ${port})")
        done
        
        # Kill the process
        if kill "$pid" 2>/dev/null; then
            # Wait a bit and verify it's actually killed
            sleep 0.5
            if ! kill -0 "$pid" 2>/dev/null; then
                echo "âœ… Disconnected ${#ports[@]} service(s):"
                for service_info in "${services_info[@]}"; do
                    echo "   - ${service_info}"
                    ((disconnected++))
                done
                log "INFO" "Disconnected PID $pid (ports: ${ports[@]})"
            else
                echo "âš ï¸  Process still running, trying force kill..."
                kill -9 "$pid" 2>/dev/null
                sleep 0.5
                if ! kill -0 "$pid" 2>/dev/null; then
                    echo "âœ… Force disconnected ${#ports[@]} service(s):"
                    for service_info in "${services_info[@]}"; do
                        echo "   - ${service_info}"
                        ((disconnected++))
                    done
                else
                    echo "âŒ Failed to disconnect ${#ports[@]} service(s):"
                    for service_info in "${services_info[@]}"; do
                        echo "   - ${service_info}"
                        ((failed_disconnect++))
                    done
                fi
            fi
        else
            echo "âŒ Failed to disconnect ${#ports[@]} service(s) (permission denied?):"
            for service_info in "${services_info[@]}"; do
                echo "   - ${service_info}"
                ((failed_disconnect++))
            done
        fi
    done
    
        # Display analytics
        echo ""
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "ğŸ“Š DISCONNECTION ANALYTICS"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "âœ… Disconnected:     ${disconnected}"
        echo "â„¹ï¸  Disconnected:    ${not_connected}"
        [[ $failed_disconnect -gt 0 ]] && echo "âŒ Failed:            ${failed_disconnect}"
        echo "ğŸ“ˆ Total services:   $((disconnected + not_connected + failed_disconnect))"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
    } 2>&1 | filter_debug
}

# Show all forwarded ports
show_forward_port() {
    # Disable any debug/trace output
    set +x 2>/dev/null
    
    {
        local connected=0
        local not_connected=0
        local invalid_configs=0
        local invalid_configs_list=()
        
        # Print table header with proper spacing
        printf "%-5s  %-15s  %-18s  %-18s  %-10s  %-15s  %-8s\n" "STAT" "SERVICE" "LOCAL PORT" "TARGET PORT" "VIA" "IP" "UPTIME"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        
        # Process all services and display in table format
        # Always load secrets to ensure we have the latest configurations
        load_secrets
        
        if [[ ${#VPS_CONFIGS[@]} -eq 0 ]]; then
            echo "âš ï¸  No VPS configurations found. Please check your secrets file."
            echo ""
            return
        fi
        
        for config in "${VPS_CONFIGS[@]}"; do
            local vps_name user ip service_name local_port target_host target_port
            
            # Skip empty configs (from comments or blank lines)
            if [[ -z "$config" ]] || [[ "$config" =~ ^[[:space:]]*$ ]]; then
                continue
            fi
            
            # Parse config - don't use subshell to preserve variables
            local parse_error_file=$(mktemp)
            if ! parse_config "$config" vps_name user ip service_name local_port target_host target_port 2>"$parse_error_file"; then
                ((invalid_configs++))
                invalid_configs_list+=("$config")
                local parse_error=$(cat "$parse_error_file" 2>/dev/null)
                if [[ -n "$parse_error" ]]; then
                    echo "$parse_error" | filter_debug >&2
                fi
                rm -f "$parse_error_file"
                continue
            fi
            rm -f "$parse_error_file"
            
            local status_icon=""
            local uptime=""
            local target_info="${target_host}:${target_port}"
            
            if is_port_in_use "${local_port}"; then
                if is_our_ssh_tunnel "${local_port}"; then
                    status_icon="ğŸŸ¢"
                    uptime=$(get_tunnel_uptime "${local_port}" 2>/dev/null)
                    ((connected++))
                else
                    status_icon="âš ï¸"
                    uptime="Other"
                fi
            else
                status_icon="ğŸ”´"
                uptime="-"
                ((not_connected++))
            fi
            
            # Prepare display values (no truncation needed with better column widths)
            local display_service="${service_name}"
            local display_local="localhost:${local_port}"
            local display_target="${target_info}"
            local display_via="${vps_name}"
            local display_ip="${ip}"
            
            # Print single row per service only - this is the ONLY output for each service
            printf "%-4s  %-15s  %-18s  %-18s  %-10s  %-15s  %-8s\n" \
                "${status_icon}" \
                "${display_service}" \
                "${display_local}" \
                "${display_target}" \
                "${display_via}" \
                "${display_ip}" \
                "${uptime}"
        done
        
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        
        # Display summary
        if [[ $invalid_configs -gt 0 ]]; then
            echo ""
            echo "âš ï¸  ${invalid_configs} invalid config(s) - check secrets file format"
        fi
        
        if [[ ${#VPS_CONFIGS[@]} -gt 0 ]]; then
            echo ""
            echo "Summary: ğŸŸ¢ ${connected} connected  |  ğŸ”´ ${not_connected} disconnected"
        fi
    } 2>&1 | filter_debug
}

# Test SSH connectivity to all VPS
test_connections() {
    # Load secrets first to ensure VPS_CONFIGS is available
    load_secrets
    
    {
        echo "ğŸ§ª Testing SSH connectivity to all VPS..."
        echo ""
        
        local success=0
        local failed=0
        typeset -A vps_hosts
        
        # Collect unique VPS hosts
        for config in "${VPS_CONFIGS[@]}"; do
            local vps_name user ip service_name local_port target_host target_port
            
            # Parse config and suppress debug output
            {
                if ! parse_config "$config" vps_name user ip service_name local_port target_host target_port; then
                    continue
                fi
            } 2>/dev/null
            
            local vps_key="${vps_name}|${user}|${ip}"
            if [[ -z "${vps_hosts[$vps_key]}" ]]; then
                vps_hosts[$vps_key]="${user}|${ip}"
            fi
        done
        
        # Test each VPS
        for vps_key in ${(k)vps_hosts}; do
            IFS='|' read -r vps_name user ip <<< "$vps_key"
            
            echo -n "Testing ${vps_name} (${ip})... "
            echo ""
            if test_ssh_connection "$user" "$ip" "$vps_name"; then
                echo "âœ… OK"
                ((success++))
            else
                echo "âŒ FAILED"
                ((failed++))
            fi
        done
        
        echo ""
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "ğŸ“Š TEST RESULTS"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "âœ… Successful:       ${success}"
        echo "âŒ Failed:           ${failed}"
        echo "ğŸ“ˆ Total VPS:        $((success + failed))"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
    } 2>&1 | filter_debug
}

# =============================================================================
# Sync Module - Utility Functions
# =============================================================================

# Helper function to extract hostname from PostgreSQL URL
extract_postgres_host() {
    local url="$1"
    # Remove postgresql:// prefix
    local url_no_prefix=$(echo "$url" | sed 's/postgresql:\/\///')
    # Extract host from URL (between @ and :port)
    local host_port=$(echo "$url_no_prefix" | rev | cut -d@ -f1 | rev)
    local host=$(echo "$host_port" | cut -d: -f1)
    echo "$host"
}

# Helper function to extract hostname from MongoDB URI
extract_mongo_host() {
    local uri="$1"
    # Handle mongodb:// and mongodb+srv:// formats
    local uri_no_prefix=$(echo "$uri" | sed 's|mongodb+srv://||' | sed 's|mongodb://||')
    # Extract host from URI (between @ and / or ?)
    local host=$(echo "$uri_no_prefix" | cut -d@ -f2 | cut -d/ -f1 | cut -d'?' -f1 | cut -d: -f1)
    echo "$host"
}

# Function to get PostgreSQL source configuration by index
get_postgres_source_config() {
    local index="$1"
    local array_length=${#POSTGRES_SOURCES[@]}

    # Convert to integer for comparison
    index=$((index + 0))

    if [ $index -ge 1 ] && [ $index -le $array_length ]; then
        echo "${POSTGRES_SOURCES[$index]}"
    else
        echo ""
    fi
}

# Function to get PostgreSQL target configuration by index
get_postgres_target_config() {
    local index="$1"
    local array_length=${#POSTGRES_TARGETS[@]}
    
    # Convert to integer for comparison
    index=$((index + 0))
    
    if [ $index -ge 1 ] && [ $index -le $array_length ]; then
        echo "${POSTGRES_TARGETS[$index]}"
    else
        echo ""
    fi
}

# Function to get PostgreSQL database from source by index
get_postgres_source_database() {
    local source_index="$1"
    local source_config=$(get_postgres_source_config "$source_index")

    if [ -z "$source_config" ]; then
        echo ""
        return 1
    fi

    IFS='|' read -r name url database <<< "$source_config"
    echo "${database}"
}

# Helper function to parse PostgreSQL URL components
_parse_postgres_url() {
    local url="$1"
    local prefix="$2"  # 'src' or 'tgt'
    
    # Remove postgresql:// prefix
    local url_no_prefix="${url#postgresql://}"
    
    # Split by the last @ (the one before hostname)
    local auth_part="${url_no_prefix%@*}"
    local host_part="${url_no_prefix##*@}"
    
    # Extract user and password
    local user="${auth_part%%:*}"
    local pass="${auth_part#*:}"
    
    # Extract host and port (handle query params)
    local host="${host_part%%:*}"
    local port_and_params="${host_part#*:}"
    local port="${port_and_params%%[?/]*}"
    
    # Export variables with prefix
    eval "${prefix}_user='${user}'"
    eval "${prefix}_pass='${pass}'"
    eval "${prefix}_host='${host}'"
    eval "${prefix}_port='${port}'"
}

# Helper function to execute psql command with optional SSL
_exec_psql() {
    local ssl_mode="$1"
    shift
    
    if [[ "${ssl_mode}" == "require" ]]; then
        env PGSSLMODE=require "$@"
    else
        "$@"
    fi
}

# Function to find PostgreSQL 18 client version
_find_pg18_version() {
    local pg_dump_path="/opt/homebrew/opt/postgresql@18/bin/pg_dump"
    
    if [[ -f "$pg_dump_path" ]]; then
        echo "18|$pg_dump_path"
    else
        echo ""
    fi
}

sync_dots_start() {
    local message="$1"
    local pid_var_name="$2"
    
    (
        local frames=('.  ' '.. ' '...')
        local idx=1
        local count=${#frames[@]}
        # Hide cursor to prevent flickering
        printf '\033[?25l'
        while true; do
            printf "\r%s%s" "$message" "${frames[$idx]}"
            idx=$(( idx % count + 1 ))
            sleep 0.5
        done
    ) &
    
    eval "${pid_var_name}=$!"
}

sync_dots_stop() {
    local spinner_pid="$1"
    
    if [[ -n "$spinner_pid" ]]; then
        kill "$spinner_pid" >/dev/null 2>&1 || true
        wait "$spinner_pid" >/dev/null 2>&1 || true
        # Show cursor again and clear the line
        printf '\033[?25h\r'
    fi
}

# Function to perform PostgreSQL sync
perform_postgres_sync() {
    local src_url="$1"
    local src_db="$2"
    local tgt_url="$3"
    local quiet_mode="${4:-false}"   # Optional 4th parameter for quiet mode
    local verbose_mode="${5:-false}" # Optional 5th parameter for verbose mode
    
    # Parse URLs
    _parse_postgres_url "$src_url" "src"
    _parse_postgres_url "$tgt_url" "tgt"
    
    # Determine SSL mode
    local tgt_sslmode="disable"
    [[ "$tgt_url" =~ sslmode=require ]] && tgt_sslmode="require"
    
    # Use PostgreSQL 18 client tools (backward compatible with 16, 17, 18)
    local pg_info=$(_find_pg18_version)
    
    if [[ -z "$pg_info" ]]; then
        echo "âŒ Error: PostgreSQL 18 client tools not found"
        echo "   Please install PostgreSQL 18: brew install postgresql@18"
        return 1
    fi
    
    # Extract version and path
    local pg_version=$(echo "$pg_info" | cut -d'|' -f1)
    local pg_dump_path=$(echo "$pg_info" | cut -d'|' -f2)
    
    # Use PostgreSQL 18 for all tools (works for all lower versions: 16, 17, 18)
    local psql_bin="/opt/homebrew/opt/postgresql@${pg_version}/bin/psql"
    local pg_dump_bin="$pg_dump_path"
    local pg_restore_bin="/opt/homebrew/opt/postgresql@${pg_version}/bin/pg_restore"
    
    # Extra args for verbose mode
    local pg_dump_args=()
    local pg_restore_args=()
    local psql_restore_args=()
    
    if [[ "$verbose_mode" == "true" ]]; then
        pg_dump_args+=("-v")
        pg_restore_args+=("--verbose")
    fi
    
    # Only show header in non-quiet mode
    if [[ "$quiet_mode" != "true" ]]; then
        echo "====================================="
        echo "PostgreSQL Sync: ${src_db}"
        echo "Source: ${src_user}@${src_host}:${src_port}"
        echo "Target: ${tgt_user}@${tgt_host}:${tgt_port}"
        echo "-------------------------------------"
    fi
    
    if [[ "$quiet_mode" != "true" ]]; then
        echo "ğŸ”§ Terminating active connections on target..."
    fi
    _exec_psql "$tgt_sslmode" \
        env PGPASSWORD="${tgt_pass}" "$psql_bin" \
        -h "${tgt_host}" -p "${tgt_port}" -U "${tgt_user}" -d postgres \
        -t -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname='${src_db}' AND pid <> pg_backend_pid();" \
        >/dev/null 2>&1 || true
    
    if [[ "$quiet_mode" != "true" ]]; then
        echo "ğŸ§¹ Dropping target database if it exists..."
    fi
    _exec_psql "$tgt_sslmode" \
        env PGPASSWORD="${tgt_pass}" "$psql_bin" \
        -h "${tgt_host}" -p "${tgt_port}" -U "${tgt_user}" -d postgres \
        -c "DROP DATABASE IF EXISTS \"${src_db}\";" \
        >/dev/null 2>&1 || true
    
    if [[ "$quiet_mode" != "true" ]]; then
        echo "ğŸ†• Creating fresh target database..."
    fi
    local create_error=$(
        _exec_psql "$tgt_sslmode" \
            env PGPASSWORD="${tgt_pass}" "$psql_bin" \
            -h "${tgt_host}" -p "${tgt_port}" -U "${tgt_user}" -d postgres \
            -c "CREATE DATABASE \"${src_db}\";" \
            2>&1 >/dev/null
    )
    
    if [ $? -ne 0 ]; then
        echo "âŒ Failed to create database '${src_db}'"
        if [[ -n "$create_error" ]]; then
            echo "   Error: $(echo "$create_error" | head -n 1)"
        fi
        return 1
    fi
    
    if [[ "$quiet_mode" != "true" ]]; then
        echo "ğŸ” Detecting database versions..."
    fi
    
    # Detect source version
    local src_version=$(env PGPASSWORD="${src_pass}" "$psql_bin" -h "${src_host}" -p "${src_port}" -U "${src_user}" -d postgres -t -c "SELECT version();" 2>/dev/null | grep -oE "PostgreSQL [0-9]+" | grep -oE "[0-9]+" | head -1)
    if [[ "$quiet_mode" != "true" ]] && [[ -n "$src_version" ]]; then
        echo "   Source version: PostgreSQL ${src_version}"
    fi
    
    # Detect target version
    local tgt_version=$(env PGPASSWORD="${tgt_pass}" "$psql_bin" -h "${tgt_host}" -p "${tgt_port}" -U "${tgt_user}" -d postgres -t -c "SELECT version();" 2>/dev/null | grep -oE "PostgreSQL [0-9]+" | grep -oE "[0-9]+" | head -1)
    if [[ "$quiet_mode" != "true" ]] && [[ -n "$tgt_version" ]]; then
        echo "   Target version: PostgreSQL ${tgt_version}"
    fi
    
    local sync_dots_pid=""
    if [[ "$quiet_mode" != "true" ]] && [[ "$verbose_mode" != "true" ]]; then
        sync_dots_start "ğŸ“¤ Syncing database" sync_dots_pid
    else
        [[ "$quiet_mode" != "true" ]] && echo "ğŸ“¤ Syncing database"
    fi
    
    # Capture errors from both dump and restore
    local dump_error_file=$(mktemp)
    local restore_error_file=$(mktemp)
    
    # If target is PostgreSQL 16 or earlier, use SQL format and filter incompatible parameters
    # Otherwise use custom format for better performance
    local sync_result=0
    
    if [[ -n "$tgt_version" ]] && [[ "$tgt_version" -le 16 ]]; then
        # Use SQL format and filter out PostgreSQL 17+ specific parameters
        env PGPASSWORD="${src_pass}" "$pg_dump_bin" "${pg_dump_args[@]}" \
            -h "${src_host}" -p "${src_port}" -U "${src_user}" -d "${src_db}" \
            --no-owner --no-acl --clean --if-exists 2> >(tee "$dump_error_file" >&2) \
        | grep -v "transaction_timeout" \
        | grep -v "ALTER DATABASE.*SET transaction_timeout" \
        | {
            # Build psql restore args
            psql_restore_args=( \
                -h "${tgt_host}" \
                -p "${tgt_port}" \
                -U "${tgt_user}" \
                -d "${src_db}" \
            )
            if [[ "$verbose_mode" != "true" ]]; then
                psql_restore_args+=("-q")
            fi
            _exec_psql "$tgt_sslmode" \
                env PGPASSWORD="${tgt_pass}" "$psql_bin" "${psql_restore_args[@]}" \
                2> >(tee "$restore_error_file" >&2) >/dev/null
        }
        sync_result=$?
    else
        # Use custom format for PostgreSQL 17+ targets
        env PGPASSWORD="${src_pass}" "$pg_dump_bin" "${pg_dump_args[@]}" \
            -h "${src_host}" -p "${src_port}" -U "${src_user}" -d "${src_db}" -Fc 2> >(tee "$dump_error_file" >&2) \
        | {
            # Build pg_restore args
            pg_restore_args+=( \
                -h "${tgt_host}" \
                -p "${tgt_port}" \
                -U "${tgt_user}" \
                -d "${src_db}" \
                --clean --if-exists --no-owner --no-acl \
            )
            _exec_psql "$tgt_sslmode" \
                env PGPASSWORD="${tgt_pass}" "$pg_restore_bin" "${pg_restore_args[@]}" \
                2> >(tee "$restore_error_file" >&2) >/dev/null
        }
        sync_result=$?
    fi
    
    if [[ -n "$sync_dots_pid" ]]; then
        sync_dots_stop "$sync_dots_pid"
        echo ""
    fi
    
    if [ $sync_result -eq 0 ]; then
        echo "âœ… '${src_db}' synced successfully"
        [[ "$quiet_mode" != "true" ]] && echo "====================================="
        rm -f "$dump_error_file" "$restore_error_file"
        return 0
    else
        echo "âŒ Sync failed for '${src_db}'"
        
        # Show dump errors if any
        if [[ -s "$dump_error_file" ]]; then
            echo "   Dump errors:"
            # Show first few error lines
            head -n 5 "$dump_error_file" | sed 's/^/      /'
            if [[ $(wc -l < "$dump_error_file") -gt 5 ]]; then
                echo "      ... (more errors in dump)"
            fi
        fi
        
        # Show restore errors if any
        if [[ -s "$restore_error_file" ]]; then
            echo "   Restore errors:"
            # Show first few error lines
            head -n 5 "$restore_error_file" | sed 's/^/      /'
            if [[ $(wc -l < "$restore_error_file") -gt 5 ]]; then
                echo "      ... (more errors in restore)"
            fi
        fi
        
        # If no errors in files but sync failed, show exit code
        if [[ ! -s "$dump_error_file" ]] && [[ ! -s "$restore_error_file" ]]; then
            echo "   Exit code: $sync_result"
            echo "   Check connection and permissions"
        fi
        
        [[ "$quiet_mode" != "true" ]] && echo "====================================="
        rm -f "$dump_error_file" "$restore_error_file"
        return 1
    fi
}

# Function to get MongoDB source configuration by index
get_mongodb_source_config() {
    local index="$1"
    local array_length=${#MONGO_SOURCES[@]}
    
    # Convert to integer for comparison
    index=$((index + 0))
    
    if [ $index -ge 1 ] && [ $index -le $array_length ]; then
        echo "${MONGO_SOURCES[$index]}"
    else
        echo ""
    fi
}

# Function to get MongoDB target configuration by index
get_mongodb_target_config() {
    local index="$1"
    local array_length=${#MONGO_TARGETS[@]}
    
    # Convert to integer for comparison
    index=$((index + 0))
    
    if [ $index -ge 1 ] && [ $index -le $array_length ]; then
        echo "${MONGO_TARGETS[$index]}"
    else
        echo ""
    fi
}

# Function to get database from MongoDB source by index
get_mongodb_source_database() {
    local source_index="$1"
    local db_index="$2"
    local source_config=$(get_mongodb_source_config "$source_index")
    
    if [ -z "$source_config" ]; then
        echo ""
        return 1
    fi
    
    IFS='|' read -r name uri databases <<< "$source_config"
    IFS=',' read -A db_array <<< "$databases"
    local array_length=${#db_array[@]}
    
    if [ "$db_index" -ge 1 ] && [ "$db_index" -le "$array_length" ]; then
        echo "${db_array[$db_index]}"
    else
        echo ""
    fi
}

# Function to test PostgreSQL connection
test_postgres_connection() {
    local url="$1"
    local name="$2"
    local quiet="${3:-false}"
    
    [[ "$quiet" != "true" ]] && echo "ğŸ” Testing connection to ${name}..."
    
    # Parse URL to extract connection details
    _parse_postgres_url "$url" "test"
    
    # Determine SSL mode
    local ssl_mode="disable"
    [[ "$url" =~ sslmode=require ]] && ssl_mode="require"
    
    # Find PostgreSQL client
    local pg_info=$(_find_pg18_version)
    if [[ -z "$pg_info" ]]; then
        # If PostgreSQL client not found, skip test but return success (can't test)
        [[ "$quiet" != "true" ]] && echo "âš ï¸  Cannot test connection (PostgreSQL client not found), proceeding anyway..."
        return 0
    fi
    
    local pg_version=$(echo "$pg_info" | cut -d'|' -f1)
    local psql_bin="/opt/homebrew/opt/postgresql@${pg_version}/bin/psql"
    
    # Test connection by running a simple query
    local conn_error_file=$(mktemp)
    
    if _exec_psql "$ssl_mode" \
        env PGPASSWORD="${test_pass}" "$psql_bin" \
        -h "${test_host}" -p "${test_port}" -U "${test_user}" -d postgres \
        -t -c "SELECT 1;" >/dev/null 2>"$conn_error_file"; then
        [[ "$quiet" != "true" ]] && echo "âœ… Connection to ${name} successful"
        rm -f "$conn_error_file"
        return 0
    fi
    
    # Connection failed
    rm -f "$conn_error_file"
    return 1
}

# Function to test MongoDB connection
test_mongo_connection() {
    local uri="$1"
    local name="$2"
    local quiet="${3:-false}"
    
    [[ "$quiet" != "true" ]] && echo "ğŸ” Testing connection to ${name}..."
    
    # Test connection by trying to list databases using mongosh or mongo
    # This doesn't require a specific database to exist
    local conn_error_file=$(mktemp)
    
    if command -v mongosh >/dev/null 2>&1; then
        # Use mongosh if available
        if mongosh "${uri}" --quiet --eval "db.adminCommand('ping')" >/dev/null 2>"$conn_error_file"; then
            [[ "$quiet" != "true" ]] && echo "âœ… Connection to ${name} successful"
            rm -f "$conn_error_file"
            return 0
        fi
    elif command -v mongo >/dev/null 2>&1; then
        # Fallback to legacy mongo client
        if mongo "${uri}" --quiet --eval "db.adminCommand('ping')" >/dev/null 2>"$conn_error_file"; then
            [[ "$quiet" != "true" ]] && echo "âœ… Connection to ${name} successful"
            rm -f "$conn_error_file"
            return 0
        fi
    else
        # If neither mongosh nor mongo is available, skip connection test
        [[ "$quiet" != "true" ]] && echo "âš ï¸  Cannot test connection (mongosh/mongo not found), proceeding anyway..."
        rm -f "$conn_error_file"
        return 0
    fi
    
    # Connection failed - show error details
    echo "âŒ Failed to connect to ${name}"
    if [[ -s "$conn_error_file" ]]; then
        local conn_err=$(grep -i "error\|failed\|exception\|refused" "$conn_error_file" | head -n 1)
        if [[ -n "$conn_err" ]]; then
            echo "   Error: $conn_err"
        else
            # If no specific error found, show first non-empty line
            local first_line=$(grep -v "^$" "$conn_error_file" | head -n 1)
            [[ -n "$first_line" ]] && echo "   Error: $first_line"
        fi
    fi
    
    rm -f "$conn_error_file"
    return 1
}

# Function to perform actual MongoDB sync
perform_mongo_sync() {
    local source_uri="$1"
    local source_db="$2"
    local source_name="$3"
    local target_uri="$4"
    local target_name="$5"
    local quiet_mode="${6:-false}"   # Optional 6th parameter for quiet mode
    local verbose_mode="${7:-false}"  # Optional 7th parameter for verbose mode
    
    # Only show header in non-quiet mode
    if [[ "$quiet_mode" != "true" ]]; then
        echo "====================================="
        echo "MongoDB Sync: ${source_db}"
        echo "Source: ${source_name}"
        echo "Target: ${target_name}"
        echo "-------------------------------------"
    fi
    
    if [[ "$quiet_mode" != "true" ]]; then
        echo "ğŸ” Testing source connection..."
    fi
    if ! test_mongo_connection "${source_uri}" "${source_name}" "$quiet_mode"; then
        [[ "$quiet_mode" != "true" ]] && echo "âŒ Cannot proceed - source connection failed"
        return 1
    fi
    
    if [[ "$quiet_mode" != "true" ]]; then
        echo "ğŸ” Testing target connection..."
    fi
    if ! test_mongo_connection "${target_uri}" "${target_name}" "$quiet_mode"; then
        [[ "$quiet_mode" != "true" ]] && echo "âŒ Cannot proceed - target connection failed"
        return 1
    fi
    
    # Detect MongoDB versions
    if [[ "$quiet_mode" != "true" ]]; then
        echo "ğŸ” Detecting database versions..."
        
        # Detect source version
        if command -v mongosh >/dev/null 2>&1; then
            local src_version=$(mongosh "${source_uri}" --quiet --eval "db.version()" 2>/dev/null | tail -1)
            [[ -n "$src_version" ]] && echo "   Source version: MongoDB ${src_version}"
        elif command -v mongo >/dev/null 2>&1; then
            local src_version=$(mongo "${source_uri}" --quiet --eval "db.version()" 2>/dev/null | tail -1)
            [[ -n "$src_version" ]] && echo "   Source version: MongoDB ${src_version}"
        fi
        
        # Detect target version
        if command -v mongosh >/dev/null 2>&1; then
            local tgt_version=$(mongosh "${target_uri}" --quiet --eval "db.version()" 2>/dev/null | tail -1)
            [[ -n "$tgt_version" ]] && echo "   Target version: MongoDB ${tgt_version}"
        elif command -v mongo >/dev/null 2>&1; then
            local tgt_version=$(mongo "${target_uri}" --quiet --eval "db.version()" 2>/dev/null | tail -1)
            [[ -n "$tgt_version" ]] && echo "   Target version: MongoDB ${tgt_version}"
        fi
    fi
    
    local mongo_dots_pid=""
    if [[ "$quiet_mode" != "true" ]] && [[ "$verbose_mode" != "true" ]]; then
        sync_dots_start "ğŸ“¤ Syncing database" mongo_dots_pid
    else
        [[ "$quiet_mode" != "true" ]] && echo "ğŸ“¤ Syncing database"
    fi
    
    # Perform the sync (capture errors)
    local mongo_error_file=$(mktemp)
    
    if [[ "$verbose_mode" == "true" ]]; then
        # Verbose mode: show all output
        mongodump --uri="${source_uri}" --db="${source_db}" --archive --gzip 2> >(tee "$mongo_error_file" >&2) \
        | mongorestore --uri="${target_uri}" --drop --archive --gzip --nsFrom="${source_db}.*" --nsTo="${source_db}.*" 2> >(tee -a "$mongo_error_file" >&2)
    else
        # Non-verbose mode: hide output, only capture errors
        mongodump --uri="${source_uri}" --db="${source_db}" --archive --gzip 2>"$mongo_error_file" \
        | mongorestore --uri="${target_uri}" --drop --archive --gzip --nsFrom="${source_db}.*" --nsTo="${source_db}.*" 2>>"$mongo_error_file" >/dev/null
    fi
    
    local sync_result=$?
    
    if [[ -n "$mongo_dots_pid" ]]; then
        sync_dots_stop "$mongo_dots_pid"
        echo ""
    fi
    
    if [ $sync_result -eq 0 ]; then
        [[ "$quiet_mode" != "true" ]] && echo "âœ… MongoDB synced successfully"
        [[ "$quiet_mode" != "true" ]] && echo "====================================="
        rm -f "$mongo_error_file"
        return 0
    else
        [[ "$quiet_mode" != "true" ]] && echo "âŒ MongoDB sync failed"
        
        # Show error details
        if [[ -s "$mongo_error_file" ]]; then
            local mongo_err=$(grep -i "error\|failed\|exception" "$mongo_error_file" | head -n 1)
            [[ -n "$mongo_err" ]] && echo "   Error: $mongo_err"
        fi
        
        [[ "$quiet_mode" != "true" ]] && echo "====================================="
        rm -f "$mongo_error_file"
        return 1
    fi
}

# Function to list all sync configurations
list_all_configs() {
    local check_status="${1:-false}"  # Default to false (no status check)
    
    # Load secrets first to ensure configuration arrays are available
    load_secrets
    
    local pg_sources_connected=0
    local pg_sources_disconnected=0
    local pg_targets_connected=0
    local pg_targets_disconnected=0
    local mongo_sources_connected=0
    local mongo_sources_disconnected=0
    local mongo_targets_connected=0
    local mongo_targets_disconnected=0
    
    echo ""
    echo "ğŸ˜ PostgreSQL Sources (${#POSTGRES_SOURCES[@]}):"
    if [[ ${#POSTGRES_SOURCES[@]} -gt 0 ]]; then
        local i=1
        for source in "${POSTGRES_SOURCES[@]}"; do
            IFS='|' read -r name url database <<< "$source"
            local host=$(extract_postgres_host "$url")
            
            # Test connection if check_status is enabled
            local status_icon=""
            if [[ "$check_status" == "true" ]]; then
                if test_postgres_connection "$url" "$name" "true" >/dev/null 2>&1; then
                    status_icon="ğŸŸ¢ "
                    ((pg_sources_connected++))
                else
                    status_icon="ğŸ”´ "
                    ((pg_sources_disconnected++))
                fi
            fi
            
            echo "  ${status_icon}${i}) ${name} â†’ ${database} | ${host}"
            i=$((i + 1))
        done
    else
        echo "  (No PostgreSQL sources configured)"
    fi
    
    echo ""
    echo "ğŸ¯ PostgreSQL Targets (${#POSTGRES_TARGETS[@]}):"
    if [[ ${#POSTGRES_TARGETS[@]} -gt 0 ]]; then
        local i=1
        for target in "${POSTGRES_TARGETS[@]}"; do
            IFS='|' read -r name url <<< "$target"
            local host=$(extract_postgres_host "$url")
            # Extract sslmode from URL for display
            local ssl_display="disable"
            if echo "$url" | grep -q "sslmode=require"; then
                ssl_display="require"
            fi
            
            # Test connection if check_status is enabled
            local status_icon=""
            if [[ "$check_status" == "true" ]]; then
                if test_postgres_connection "$url" "$name" "true" >/dev/null 2>&1; then
                    status_icon="ğŸŸ¢ "
                    ((pg_targets_connected++))
                else
                    status_icon="ğŸ”´ "
                    ((pg_targets_disconnected++))
                fi
            fi
            
            echo "  ${status_icon}${i}) ${name} | ${host} [SSL: ${ssl_display}]"
            i=$((i + 1))
        done
    else
        echo "  (No PostgreSQL targets configured)"
    fi
    
    echo ""
    echo "ğŸƒ MongoDB Sources (${#MONGO_SOURCES[@]}):"
    if [[ ${#MONGO_SOURCES[@]} -gt 0 ]]; then
        local i=1
        for source in "${MONGO_SOURCES[@]}"; do
            IFS='|' read -r name uri databases <<< "$source"
            local host=$(extract_mongo_host "$uri")
            
            # Test connection if check_status is enabled
            local status_icon=""
            if [[ "$check_status" == "true" ]]; then
                if test_mongo_connection "${uri}" "${name}" "true" >/dev/null 2>&1; then
                    status_icon="ğŸŸ¢ "
                    ((mongo_sources_connected++))
                else
                    status_icon="ğŸ”´ "
                    ((mongo_sources_disconnected++))
                fi
            fi
            
            echo "  ${status_icon}${i}) ${name} â†’ ${databases} | ${host}"
            i=$((i + 1))
        done
    else
        echo "  (No MongoDB sources configured)"
    fi
    
    echo ""
    echo "ğŸ¯ MongoDB Targets (${#MONGO_TARGETS[@]}):"
    if [[ ${#MONGO_TARGETS[@]} -gt 0 ]]; then
        local i=1
        for target in "${MONGO_TARGETS[@]}"; do
            IFS='|' read -r name uri <<< "$target"
            local host=$(extract_mongo_host "$uri")
            
            # Test connection if check_status is enabled
            local status_icon=""
            if [[ "$check_status" == "true" ]]; then
                if test_mongo_connection "${uri}" "${name}" "true" >/dev/null 2>&1; then
                    status_icon="ğŸŸ¢ "
                    ((mongo_targets_connected++))
                else
                    status_icon="ğŸ”´ "
                    ((mongo_targets_disconnected++))
                fi
            fi
            
            echo "  ${status_icon}${i}) ${name} | ${host}"
            i=$((i + 1))
        done
    else
        echo "  (No MongoDB targets configured)"
    fi
    
    # Display summary only if check_status is enabled
    if [[ "$check_status" == "true" ]]; then
        if [[ ${#POSTGRES_SOURCES[@]} -gt 0 ]] || [[ ${#POSTGRES_TARGETS[@]} -gt 0 ]] || \
           [[ ${#MONGO_SOURCES[@]} -gt 0 ]] || [[ ${#MONGO_TARGETS[@]} -gt 0 ]]; then
            # Calculate totals
            local total_connected=$((pg_sources_connected + pg_targets_connected + mongo_sources_connected + mongo_targets_connected))
            local total_disconnected=$((pg_sources_disconnected + pg_targets_disconnected + mongo_sources_disconnected + mongo_targets_disconnected))
            
            echo ""
            echo "Summary: ğŸŸ¢ ${total_connected} connected  |  ğŸ”´ ${total_disconnected} disconnected"
        fi
    fi
    
    echo ""
}

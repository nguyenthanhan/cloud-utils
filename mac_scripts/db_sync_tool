#!/bin/zsh

# =============================================================================
# Database Sync Tool - PostgreSQL & MongoDB Synchronization
# =============================================================================
# This script provides tools to sync databases between PostgreSQL and MongoDB
# sources and targets. Database configurations are loaded from secrets file.
#
# Secrets file location:
#   ~/Library/Mobile Documents/com~apple~CloudDocs/Backups/mac_scripts_secrets
#
# Required arrays in secrets file:
#   - POSTGRES_SOURCES: Format "name|postgresql://user:pass@host:port/db|database"
#   - POSTGRES_TARGETS: Format "name|postgresql://user:pass@host:port/db?sslmode=require"
#   - MONGO_SOURCES: Format "name|mongodb://user:pass@host:port|db1,db2,db3"
#   - MONGO_TARGETS: Format "name|mongodb://user:pass@host:port"
#
# To add/remove databases: Edit arrays in the secrets file
# =============================================================================

# Configuration file path (where database configs are stored)
export DB_CONFIG_FILE="${DB_CONFIG_FILE:-${HOME}/.zsh_functions/sync_db.sh}"

# Try multiple methods to get script directory
if [[ -n "${(%):-%x}" ]]; then
    # When sourced in zsh
    SCRIPT_DIR="$(cd "$(dirname "${(%):-%x}")" && pwd 2>/dev/null)"
fi
if [[ -z "$SCRIPT_DIR" ]] && [[ -n "$0" ]] && [[ "$0" != "-zsh" ]] && [[ "$0" != "zsh" ]]; then
    # When executed directly
    SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd 2>/dev/null)"
fi
# Fallback: use default location
SCRIPT_DIR="${SCRIPT_DIR:-${HOME}/Documents/traefik-cloud/mac_scripts}"

# =============================================================================
# MAIN ENTRY POINT
# =============================================================================

# Main database sync function with flag support
# Auto-loads database configurations from secrets file on each call
db_sync_tool() {
    # Auto-load secrets from secrets file every time function is called
    # This ensures we always use the latest database configurations
    local icloud_drive_root="${HOME}/Library/Mobile Documents/com~apple~CloudDocs"
    local secrets_file="${icloud_drive_root}/Backups/mac_scripts_secrets"
    
    if [[ -f "$secrets_file" ]]; then
        source "$secrets_file" 2>/dev/null
        # Verify that required arrays are loaded
        if [[ -z "${POSTGRES_SOURCES[@]}" ]] && [[ -z "${MONGO_SOURCES[@]}" ]]; then
            echo "‚ö†Ô∏è  Warning: No database sources found in secrets file"
            echo "   Please define POSTGRES_SOURCES and/or MONGO_SOURCES in $secrets_file"
        fi
    else
        echo "‚ö†Ô∏è  Warning: Secrets file not found at $secrets_file"
        echo "   Please create the file and define database configurations:"
        echo "   - POSTGRES_SOURCES, POSTGRES_TARGETS"
        echo "   - MONGO_SOURCES, MONGO_TARGETS"
        # Set empty arrays as fallback
        export POSTGRES_SOURCES=()
        export POSTGRES_TARGETS=()
        export MONGO_SOURCES=()
        export MONGO_TARGETS=()
    fi
    
    # Parse command-line arguments
    local sync_type=""
    local source_idx=""
    local db_idx=""
    local dest_idx=""
    local list_configs=false
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                echo "üóÑÔ∏è  DATABASE SYNC TOOL"
                echo ""
                echo "USAGE:"
                echo "  db_sync_tool -p | --postgres -s <source> [-b <db>] -d <destination>"
                echo "  db_sync_tool -m | --mongo -s <source> [-b <db>] -d <destination>"
                echo "  db_sync_tool -l | --list"
                echo ""
                echo "FLAGS:"
                echo "  -p, --postgres             Sync PostgreSQL database"
                echo "  -m, --mongo                Sync MongoDB database"
                echo "  -s, --source <index>       Source index (1-based)"
                echo "  -b, --database <index>     Database index (default: 1)"
                echo "  -d, --destination <index>  Destination index (1-based)"
                echo "  -l, --list                 List all configurations"
                echo ""
                echo "EXAMPLES:"
                echo "  db_sync_tool -l                      # List configs"
                echo "  db_sync_tool -p -s 1 -d 1            # Sync PostgreSQL"
                echo "  db_sync_tool -m -s 1 -d 2            # Sync MongoDB"
                return 0
                ;;
            -l|--list)
                list_configs=true
                shift
                ;;
            -p|--postgres)
                sync_type="postgres"
                shift
                ;;
            -m|--mongo)
                sync_type="mongo"
                shift
                ;;
            -s|--source)
                source_idx="$2"
                shift 2
                ;;
            -b|--database)
                db_idx="$2"
                shift 2
                ;;
            -d|--destination)
                dest_idx="$2"
                shift 2
                ;;
            *)
                echo "‚ùå Unknown option: $1"
                echo "Use -h or --help for usage information"
                return 1
                ;;
        esac
    done
    
    # Handle list configurations
    if [[ "$list_configs" == "true" ]]; then
        list_all_configs
        return 0
    fi
    
    # Validate sync type
    if [[ -z "$sync_type" ]]; then
        echo "‚ùå Error: Sync type is required."
        echo "   Use -p/--postgres or -m/--mongo"
        echo "   Use -h for help"
        return 1
    fi
    
    # Handle different sync types
    case "$sync_type" in
        postgres|postgresql|pg)
            if [[ -z "$source_idx" ]] || [[ -z "$dest_idx" ]]; then
                echo "‚ùå Error: PostgreSQL sync requires -s (source) and -d (destination) flags"
                echo "   Use -l to list available configurations"
                return 1
            fi
            
            # Default database index to 1 if not specified
            db_idx=${db_idx:-1}
            
            # Validate source
            local source_config=$(get_postgres_source_config "$source_idx")
            if [[ -z "$source_config" ]]; then
                echo "‚ùå Error: Invalid PostgreSQL source index: $source_idx"
                echo "   Available sources: 1-${#POSTGRES_SOURCES[@]}"
                return 1
            fi
            
            # Validate destination
            local dest_config=$(get_postgres_target_config "$dest_idx")
            if [[ -z "$dest_config" ]]; then
                echo "‚ùå Error: Invalid PostgreSQL destination index: $dest_idx"
                echo "   Available destinations: 1-${#POSTGRES_TARGETS[@]}"
                return 1
            fi
            
            # Get database
            local source_db=$(get_postgres_source_database "$source_idx")
            if [[ -z "$source_db" ]]; then
                echo "‚ùå Error: Invalid database index: $db_idx"
                return 1
            fi
            
            # Parse configs
            IFS='|' read -r source_name source_url _ <<< "$source_config"
            IFS='|' read -r dest_name dest_url <<< "$dest_config"
            
            # Show configuration and sync
            echo ""
            echo "üêò PostgreSQL Sync"
            echo "=================="
            echo "  From: ${source_name} ‚Üí Database: ${source_db}"
            echo "  To: ${dest_name}"
            echo ""
            
            perform_postgres_sync "$source_url" "$source_db" "$dest_url"
            ;;
            
        mongo|mongodb)
            if [[ -z "$source_idx" ]] || [[ -z "$dest_idx" ]]; then
                echo "‚ùå Error: MongoDB sync requires -s (source) and -d (destination) flags"
                echo "   Use -l to list available configurations"
                return 1
            fi
            
            # Default database index to 1 if not specified
            db_idx=${db_idx:-1}
            
            # Validate source
            local source_config=$(get_source_config "$source_idx")
            if [[ -z "$source_config" ]]; then
                echo "‚ùå Error: Invalid MongoDB source index: $source_idx"
                echo "   Available sources: 1-${#MONGO_SOURCES[@]}"
                return 1
            fi
            
            # Validate destination
            local dest_config=$(get_target_config "$dest_idx")
            if [[ -z "$dest_config" ]]; then
                echo "‚ùå Error: Invalid MongoDB destination index: $dest_idx"
                echo "   Available destinations: 1-${#MONGO_TARGETS[@]}"
                return 1
            fi
            
            # Get database
            local source_db=$(get_source_database "$source_idx" "$db_idx")
            if [[ -z "$source_db" ]]; then
                echo "‚ùå Error: Invalid database index: $db_idx"
                return 1
            fi
            
            # Parse configs
            IFS='|' read -r source_name source_uri _ <<< "$source_config"
            IFS='|' read -r dest_name dest_uri <<< "$dest_config"
            
            # Show configuration and sync
            echo ""
            echo "üçÉ MongoDB Sync"
            echo "==============="
            echo "  From: ${source_name} ‚Üí Database: ${source_db}"
            echo "  To: ${dest_name} ‚Üí Database: ${source_db}"
            echo ""
            
            perform_mongo_sync "$source_uri" "$source_db" "${source_name}" "$dest_uri" "${dest_name}"
            ;;
            
        *)
            echo "‚ùå Error: Invalid sync type: $sync_type"
            echo "   Valid types: postgres, mongo"
            echo "   Use -h for help"
            return 1
            ;;
    esac
}

# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

# Helper function to extract hostname from PostgreSQL URL
extract_postgres_host() {
    local url="$1"
    # Remove postgresql:// prefix
    local url_no_prefix=$(echo "$url" | sed 's/postgresql:\/\///')
    # Extract host from URL (between @ and :port)
    local host_port=$(echo "$url_no_prefix" | rev | cut -d@ -f1 | rev)
    local host=$(echo "$host_port" | cut -d: -f1)
    echo "$host"
}

# Helper function to extract hostname from MongoDB URI
extract_mongo_host() {
    local uri="$1"
    # Handle mongodb:// and mongodb+srv:// formats
    local uri_no_prefix=$(echo "$uri" | sed 's|mongodb+srv://||' | sed 's|mongodb://||')
    # Extract host from URI (between @ and / or ?)
    local host=$(echo "$uri_no_prefix" | cut -d@ -f2 | cut -d/ -f1 | cut -d'?' -f1 | cut -d: -f1)
    echo "$host"
}


# Function to get PostgreSQL source configuration by index
get_postgres_source_config() {
    local index="$1"
    local array_length=${#POSTGRES_SOURCES[@]}

    # Convert to integer for comparison
    index=$((index + 0))

    if [ $index -ge 1 ] && [ $index -le $array_length ]; then
        echo "${POSTGRES_SOURCES[$index]}"
    else
        echo ""
    fi
}

# Function to get PostgreSQL target configuration by index
get_postgres_target_config() {
    local index="$1"
    local array_length=${#POSTGRES_TARGETS[@]}
    
    # Convert to integer for comparison
    index=$((index + 0))
    
    if [ $index -ge 1 ] && [ $index -le $array_length ]; then
        echo "${POSTGRES_TARGETS[$index]}"
    else
        echo ""
    fi
}

# Function to get PostgreSQL database from source by index
get_postgres_source_database() {
    local source_index="$1"
    local source_config=$(get_postgres_source_config "$source_index")

    if [ -z "$source_config" ]; then
        echo ""
        return 1
    fi

    IFS='|' read -r name url database <<< "$source_config"
    echo "${database}"
}

# Function to display PostgreSQL source options
show_postgres_sources() {
    echo "üìã Available PostgreSQL Sources:"
    local i=1
    for source in "${POSTGRES_SOURCES[@]}"; do
        IFS='|' read -r name url database <<< "$source"
        local host=$(extract_postgres_host "$url")
        echo "${i}) ${name} | ${host}"
        i=$((i + 1))
    done
}

# Function to display PostgreSQL target options
show_postgres_targets() {
    echo "üéØ Available PostgreSQL Targets:"
    local i=1
    for target in "${POSTGRES_TARGETS[@]}"; do
        IFS='|' read -r name url <<< "$target"
        local host=$(extract_postgres_host "$url")
        echo "${i}) ${name} | ${host}"
        i=$((i + 1))
    done
}

# Function to display available PostgreSQL databases for a source
show_postgres_source_databases() {
    local source_index="$1"
    local source_config=$(get_postgres_source_config "$source_index")

    if [ -z "$source_config" ]; then
        echo "‚ùå Invalid source selection"
        return 1
    fi

    IFS='|' read -r name url database <<< "$source_config"
    echo "üìä Available Databases in ${name}:"
    echo "1) ${database}"
}
# Function to perform PostgreSQL sync
# Helper function to parse PostgreSQL URL components
_parse_postgres_url() {
    local url="$1"
    local prefix="$2"  # 'src' or 'tgt'
    
    # Remove postgresql:// prefix
    local url_no_prefix="${url#postgresql://}"
    
    # Split by the last @ (the one before hostname)
    local auth_part="${url_no_prefix%@*}"
    local host_part="${url_no_prefix##*@}"
    
    # Extract user and password
    local user="${auth_part%%:*}"
    local pass="${auth_part#*:}"
    
    # Extract host and port (handle query params)
    local host="${host_part%%:*}"
    local port_and_params="${host_part#*:}"
    local port="${port_and_params%%[?/]*}"
    
    # Export variables with prefix
    eval "${prefix}_user='${user}'"
    eval "${prefix}_pass='${pass}'"
    eval "${prefix}_host='${host}'"
    eval "${prefix}_port='${port}'"
}

# Helper function to execute psql command with optional SSL
_exec_psql() {
    local ssl_mode="$1"
    shift
    
    if [[ "${ssl_mode}" == "require" ]]; then
        env PGSSLMODE=require "$@"
    else
        "$@"
    fi
}

# Function to find PostgreSQL 18 client version
_find_pg18_version() {
    local pg_dump_path="/opt/homebrew/opt/postgresql@18/bin/pg_dump"
    
    if [[ -f "$pg_dump_path" ]]; then
        echo "18|$pg_dump_path"
    else
        echo ""
    fi
}

# Function to perform PostgreSQL sync
perform_postgres_sync() {
    local src_url="$1"
    local src_db="$2"
    local tgt_url="$3"
    local quiet_mode="${4:-false}"  # Optional 4th parameter for quiet mode
    
    # Parse URLs
    _parse_postgres_url "$src_url" "src"
    _parse_postgres_url "$tgt_url" "tgt"
    
    # Determine SSL mode
    local tgt_sslmode="disable"
    [[ "$tgt_url" =~ sslmode=require ]] && tgt_sslmode="require"
    
    # Use PostgreSQL 18 client tools (backward compatible with 16, 17, 18)
    local pg_info=$(_find_pg18_version)
    
    if [[ -z "$pg_info" ]]; then
        echo "‚ùå Error: PostgreSQL 18 client tools not found"
        echo "   Please install PostgreSQL 18: brew install postgresql@18"
        return 1
    fi
    
    # Extract version and path
    local pg_version=$(echo "$pg_info" | cut -d'|' -f1)
    local pg_dump_path=$(echo "$pg_info" | cut -d'|' -f2)
    
    # Use PostgreSQL 18 for all tools (works for all lower versions: 16, 17, 18)
    local psql_bin="/opt/homebrew/opt/postgresql@${pg_version}/bin/psql"
    local pg_dump_bin="$pg_dump_path"
    local pg_restore_bin="/opt/homebrew/opt/postgresql@${pg_version}/bin/pg_restore"
    
    # Try to detect PostgreSQL version from source server (for informational purposes)
    local src_version=$(env PGPASSWORD="${src_pass}" "$psql_bin" -h "${src_host}" -p "${src_port}" -U "${src_user}" -d postgres -t -c "SELECT version();" 2>/dev/null | grep -oE "PostgreSQL [0-9]+" | grep -oE "[0-9]+" | head -1)
    
    # Only show header in non-quiet mode
    if [[ "$quiet_mode" != "true" ]]; then
        echo "====================================="
        echo "PostgreSQL Sync: ${src_db}"
        echo "Source: ${src_user}@${src_host}:${src_port}"
        echo "Target: ${tgt_user}@${tgt_host}:${tgt_port}"
        echo "-------------------------------------"
    fi
    
    # 1) Terminate active connections on target (silent)
    _exec_psql "$tgt_sslmode" \
        env PGPASSWORD="${tgt_pass}" "$psql_bin" \
        -h "${tgt_host}" -p "${tgt_port}" -U "${tgt_user}" -d postgres \
        -t -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname='${src_db}' AND pid <> pg_backend_pid();" \
        >/dev/null 2>&1 || true
    
    # 2) Drop target DB if it exists (silent)
    _exec_psql "$tgt_sslmode" \
        env PGPASSWORD="${tgt_pass}" "$psql_bin" \
        -h "${tgt_host}" -p "${tgt_port}" -U "${tgt_user}" -d postgres \
        -c "DROP DATABASE IF EXISTS \"${src_db}\";" \
        >/dev/null 2>&1 || true
    
    # 3) Create fresh target DB (capture errors)
    local create_error=$(
        _exec_psql "$tgt_sslmode" \
            env PGPASSWORD="${tgt_pass}" "$psql_bin" \
            -h "${tgt_host}" -p "${tgt_port}" -U "${tgt_user}" -d postgres \
            -c "CREATE DATABASE \"${src_db}\";" \
            2>&1 >/dev/null
    )
    
    if [ $? -ne 0 ]; then
        echo "‚ùå Failed to create database '${src_db}'"
        if [[ -n "$create_error" ]]; then
            echo "   Error: $(echo "$create_error" | head -n 1)"
        fi
        return 1
    fi
    
    # 4) Dump from source and restore into target
    [[ "$quiet_mode" != "true" ]] && echo "üì§ Syncing database..."
    
    # Detect target PostgreSQL version to handle compatibility
    local tgt_version=$(env PGPASSWORD="${tgt_pass}" "$psql_bin" -h "${tgt_host}" -p "${tgt_port}" -U "${tgt_user}" -d postgres -t -c "SELECT version();" 2>/dev/null | grep -oE "PostgreSQL [0-9]+" | grep -oE "[0-9]+" | head -1)
    
    # Capture errors from both dump and restore
    local dump_error_file=$(mktemp)
    local restore_error_file=$(mktemp)
    
    # If target is PostgreSQL 16 or earlier, use SQL format and filter incompatible parameters
    # Otherwise use custom format for better performance
    local sync_result=0
    
    if [[ -n "$tgt_version" ]] && [[ "$tgt_version" -le 16 ]]; then
        # Use SQL format and filter out PostgreSQL 17+ specific parameters
        env PGPASSWORD="${src_pass}" "$pg_dump_bin" \
            -h "${src_host}" -p "${src_port}" -U "${src_user}" -d "${src_db}" \
            --no-owner --no-acl --clean --if-exists 2>"$dump_error_file" \
        | grep -v "transaction_timeout" \
        | grep -v "ALTER DATABASE.*SET transaction_timeout" \
        | _exec_psql "$tgt_sslmode" \
            env PGPASSWORD="${tgt_pass}" "$psql_bin" \
            -h "${tgt_host}" -p "${tgt_port}" -U "${tgt_user}" -d "${src_db}" \
            -q 2>"$restore_error_file" >/dev/null
        sync_result=$?
    else
        # Use custom format for PostgreSQL 17+ targets
        env PGPASSWORD="${src_pass}" "$pg_dump_bin" \
            -h "${src_host}" -p "${src_port}" -U "${src_user}" -d "${src_db}" -Fc 2>"$dump_error_file" \
        | _exec_psql "$tgt_sslmode" \
            env PGPASSWORD="${tgt_pass}" "$pg_restore_bin" \
            -h "${tgt_host}" -p "${tgt_port}" -U "${tgt_user}" -d "${src_db}" \
            --clean --if-exists --no-owner --no-acl 2>"$restore_error_file" >/dev/null
        sync_result=$?
    fi
    
    if [ $sync_result -eq 0 ]; then
        echo "‚úÖ '${src_db}' synced successfully"
        [[ "$quiet_mode" != "true" ]] && echo "====================================="
        rm -f "$dump_error_file" "$restore_error_file"
        return 0
    else
        echo "‚ùå Sync failed for '${src_db}'"
        
        # Show dump errors if any
        if [[ -s "$dump_error_file" ]]; then
            echo "   Dump errors:"
            # Show first few error lines
            head -n 5 "$dump_error_file" | sed 's/^/      /'
            if [[ $(wc -l < "$dump_error_file") -gt 5 ]]; then
                echo "      ... (more errors in dump)"
            fi
        fi
        
        # Show restore errors if any
        if [[ -s "$restore_error_file" ]]; then
            echo "   Restore errors:"
            # Show first few error lines
            head -n 5 "$restore_error_file" | sed 's/^/      /'
            if [[ $(wc -l < "$restore_error_file") -gt 5 ]]; then
                echo "      ... (more errors in restore)"
            fi
        fi
        
        # If no errors in files but sync failed, show exit code
        if [[ ! -s "$dump_error_file" ]] && [[ ! -s "$restore_error_file" ]]; then
            echo "   Exit code: $sync_result"
            echo "   Check connection and permissions"
        fi
        
        [[ "$quiet_mode" != "true" ]] && echo "====================================="
        rm -f "$dump_error_file" "$restore_error_file"
        return 1
    fi
}

# =============================================================================
# MONGODB SYNC FUNCTIONS
# =============================================================================

# Function to display MongoDB source options
show_mongo_sources() {
    echo "üìã Available MongoDB Sources:"
    local i=1
    for source in "${MONGO_SOURCES[@]}"; do
        IFS='|' read -r name uri databases <<< "$source"
        local host=$(extract_mongo_host "$uri")
        echo "${i}) ${name} | ${host}"
        i=$((i + 1))
    done
}

# Function to display available databases for a source
show_source_databases() {
    local source_index="$1"
    local source_config=$(get_source_config "$source_index")
    
    if [ -z "$source_config" ]; then
        echo "‚ùå Invalid source selection"
        return 1
    fi
    
    IFS='|' read -r name uri databases <<< "$source_config"
    echo "üìä Available Databases in ${name}:"
    
    IFS=',' read -A db_array <<< "$databases"
    local i=1
    for db in "${db_array[@]}"; do
        echo "${i}) ${db}"
        i=$((i + 1))
    done
}

# Function to display MongoDB target options
show_mongo_targets() {
    echo "üéØ Available MongoDB Targets:"
    local i=1
    for target in "${MONGO_TARGETS[@]}"; do
        IFS='|' read -r name uri <<< "$target"
        local host=$(extract_mongo_host "$uri")
        echo "${i}) ${name} | ${host}"
        i=$((i + 1))
    done
}

# Function to get source configuration by index
get_source_config() {
    local index="$1"
    local array_length=${#MONGO_SOURCES[@]}
    
    # Convert to integer for comparison
    index=$((index + 0))
    
    if [ $index -ge 1 ] && [ $index -le $array_length ]; then
        echo "${MONGO_SOURCES[$index]}"
    else
        echo ""
    fi
}

# Function to get database from source by index
get_source_database() {
    local source_index="$1"
    local db_index="$2"
    local source_config=$(get_source_config "$source_index")
    
    if [ -z "$source_config" ]; then
        echo ""
        return 1
    fi
    
    IFS='|' read -r name uri databases <<< "$source_config"
    IFS=',' read -A db_array <<< "$databases"
    local array_length=${#db_array[@]}
    
    if [ "$db_index" -ge 1 ] && [ "$db_index" -le "$array_length" ]; then
        echo "${db_array[$db_index]}"
    else
        echo ""
    fi
}

# Function to get target configuration by index
get_target_config() {
    local index="$1"
    local array_length=${#MONGO_TARGETS[@]}
    
    # Convert to integer for comparison
    index=$((index + 0))
    
    if [ $index -ge 1 ] && [ $index -le $array_length ]; then
        echo "${MONGO_TARGETS[$index]}"
    else
        echo ""
    fi
}


# Function to list all configurations
list_all_configs() {
    echo "üóÑÔ∏è  Database Configurations"
    echo "=========================="
    
    echo ""
    echo "üêò PostgreSQL Sources (${#POSTGRES_SOURCES[@]}):"
    local i=1
    for source in "${POSTGRES_SOURCES[@]}"; do
        IFS='|' read -r name url database <<< "$source"
        echo "  ${i}) ${name} (${database})"
        i=$((i + 1))
    done
    
    echo ""
    echo "üéØ PostgreSQL Targets (${#POSTGRES_TARGETS[@]}):"
    local i=1
    for target in "${POSTGRES_TARGETS[@]}"; do
        IFS='|' read -r name url <<< "$target"
        # Extract sslmode from URL for display
        local ssl_display="disable"
        if echo "$url" | grep -q "sslmode=require"; then
            ssl_display="require"
        fi
        echo "  ${i}) ${name} [SSL: ${ssl_display}]"
        i=$((i + 1))
    done
    
    echo ""
    echo "üçÉ MongoDB Sources (${#MONGO_SOURCES[@]}):"
    local i=1
    for source in "${MONGO_SOURCES[@]}"; do
        IFS='|' read -r name uri databases <<< "$source"
        echo "  ${i}) ${name} (${databases})"
        i=$((i + 1))
    done
    
    echo ""
    echo "üéØ MongoDB Targets (${#MONGO_TARGETS[@]}):"
    local i=1
    for target in "${MONGO_TARGETS[@]}"; do
        IFS='|' read -r name uri <<< "$target"
        echo "  ${i}) ${name} (${uri})"
        i=$((i + 1))
    done
}

# Function to test MongoDB connection
test_mongo_connection() {
    local uri="$1"
    local name="$2"
    local quiet="${3:-false}"
    
    [[ "$quiet" != "true" ]] && echo "üîç Testing connection to ${name}..."
    
    # Test connection by trying to list databases using mongosh or mongo
    # This doesn't require a specific database to exist
    local conn_error_file=$(mktemp)
    
    if command -v mongosh >/dev/null 2>&1; then
        # Use mongosh if available
        if mongosh "${uri}" --quiet --eval "db.adminCommand('ping')" >/dev/null 2>"$conn_error_file"; then
            [[ "$quiet" != "true" ]] && echo "‚úÖ Connection to ${name} successful"
            rm -f "$conn_error_file"
            return 0
        fi
    elif command -v mongo >/dev/null 2>&1; then
        # Fallback to legacy mongo client
        if mongo "${uri}" --quiet --eval "db.adminCommand('ping')" >/dev/null 2>"$conn_error_file"; then
            [[ "$quiet" != "true" ]] && echo "‚úÖ Connection to ${name} successful"
            rm -f "$conn_error_file"
            return 0
        fi
    else
        # If neither mongosh nor mongo is available, skip connection test
        [[ "$quiet" != "true" ]] && echo "‚ö†Ô∏è  Cannot test connection (mongosh/mongo not found), proceeding anyway..."
        rm -f "$conn_error_file"
        return 0
    fi
    
    # Connection failed - show error details
    echo "‚ùå Failed to connect to ${name}"
    if [[ -s "$conn_error_file" ]]; then
        local conn_err=$(grep -i "error\|failed\|exception\|refused" "$conn_error_file" | head -n 1)
        if [[ -n "$conn_err" ]]; then
            echo "   Error: $conn_err"
        else
            # If no specific error found, show first non-empty line
            local first_line=$(grep -v "^$" "$conn_error_file" | head -n 1)
            [[ -n "$first_line" ]] && echo "   Error: $first_line"
        fi
    fi
    
    rm -f "$conn_error_file"
    return 1
}

# Function to perform actual MongoDB sync
perform_mongo_sync() {
    local source_uri="$1"
    local source_db="$2"
    local source_name="$3"
    local target_uri="$4"
    local target_name="$5"
    local quiet_mode="${6:-false}"  # Optional 6th parameter for quiet mode
    
    # Only show header in non-quiet mode
    if [[ "$quiet_mode" != "true" ]]; then
        echo "====================================="
        echo "MongoDB Sync: ${source_db}"
        echo "Source: ${source_name}"
        echo "Target: ${target_name}"
        echo "-------------------------------------"
    fi
    
    # Test connections (pass quiet mode to test function)
    if ! test_mongo_connection "${source_uri}" "${source_name}" "$quiet_mode"; then
        [[ "$quiet_mode" != "true" ]] && echo "‚ùå Cannot proceed - source connection failed"
        return 1
    fi
    
    if ! test_mongo_connection "${target_uri}" "${target_name}" "$quiet_mode"; then
        [[ "$quiet_mode" != "true" ]] && echo "‚ùå Cannot proceed - target connection failed"
        return 1
    fi
    
    [[ "$quiet_mode" != "true" ]] && echo "üì§ Syncing database..."
    
    # Perform the sync (capture errors)
    local mongo_error_file=$(mktemp)
    
    if [[ "$quiet_mode" == "true" ]]; then
        mongodump --uri="${source_uri}" --db="${source_db}" --archive --gzip 2>"$mongo_error_file" \
        | mongorestore --uri="${target_uri}" --drop --archive --gzip --nsFrom="${source_db}.*" --nsTo="${source_db}.*" 2>>"$mongo_error_file"
    else
        mongodump --uri="${source_uri}" --db="${source_db}" --archive --gzip 2>"$mongo_error_file" \
        | mongorestore --uri="${target_uri}" --drop --archive --gzip --nsFrom="${source_db}.*" --nsTo="${source_db}.*" 2>>"$mongo_error_file"
    fi
    
    local sync_result=$?
    
    if [ $sync_result -eq 0 ]; then
        [[ "$quiet_mode" != "true" ]] && echo "‚úÖ MongoDB synced successfully"
        [[ "$quiet_mode" != "true" ]] && echo "====================================="
        rm -f "$mongo_error_file"
        return 0
    else
        [[ "$quiet_mode" != "true" ]] && echo "‚ùå MongoDB sync failed"
        
        # Show error details
        if [[ -s "$mongo_error_file" ]]; then
            local mongo_err=$(grep -i "error\|failed\|exception" "$mongo_error_file" | head -n 1)
            [[ -n "$mongo_err" ]] && echo "   Error: $mongo_err"
        fi
        
        [[ "$quiet_mode" != "true" ]] && echo "====================================="
        rm -f "$mongo_error_file"
        return 1
    fi
}


# =============================================================================
# ENTRY POINT - Pass all command-line arguments to db_sync_tool
# =============================================================================

db_sync_tool "$@"